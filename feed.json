{
    "version": "https://jsonfeed.org/version/1",
    "title": "Web前端",
    "subtitle": "=别怕路长梦远,总有星河照耀=",
    "icon": "https://honshen.xyz/images/favicon.ico",
    "description": "欢迎来到红绳的笔记空间(๑•ᴗ•๑)~,这里,你可以阅读我的学习笔记并提出独到的见解~我们将互相学习,共同进步(≧∀≦)ゞ",
    "home_page_url": "https://honshen.xyz",
    "items": [
        {
            "id": "https://honshen.xyz/2021/02/07/Hexo/%E7%95%AA%E5%A4%96%E7%AF%87-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85(%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)/",
            "url": "https://honshen.xyz/2021/02/07/Hexo/%E7%95%AA%E5%A4%96%E7%AF%87-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85(%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)/",
            "title": "番外篇-服务器环境安装(三种方式)",
            "date_published": "2021-02-07T04:12:45.000Z",
            "content_html": "<h1 id=\"环境安装\"><a class=\"anchor\" href=\"#环境安装\">#</a> 环境安装</h1>\n<ul>\n<li>一般有三种安装方式: rpm (jdk) 解压缩 (tomcat) yum 在线安装 (docker)</li>\n<li>rmp (以安装 jdk 为例)</li>\n<li>解压缩 (以 nodejs 为例：发布网站)</li>\n<li>yun 在线安装 (docker: 运行 docker)</li>\n</ul>\n<h1 id=\"jdk安装\"><a class=\"anchor\" href=\"#jdk安装\">#</a> JDK 安装</h1>\n<ol>\n<li>\n<p>检查服务器是否存在 java 环境</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>java -version</pre></td></tr></table></figure><p>如果控制台输出 <code>-bash: java: command not found</code>  表示服务器没有安装 java</p>\n<p>如果控制台输出了 java 的版本号，我们需要卸载 java, 然后重新安装</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">rpm</span> -qa<span class=\"token operator\">|</span><span class=\"token function\">grep</span> jdk <span class=\"token comment\">#检查 jdk 的版本信息</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">rpm</span> -e --nodeps jdk版本号 <span class=\"token comment\">#强制移除 jdk 版本号，如:rpm -e --nodeps jdk1.8-1.8.0_281-fcs.x86_64</span></pre></td></tr></table></figure></li>\n<li>\n<p>下载 JDK 的 rpm 包 :  <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bi9qYXZhL2pkay84dTI4MS1iMDkvODlkNjc4ZjJiZTE2NDc4NmIyOTI1Mjc2NThjYTE2MDUvamRrLTh1MjgxLWxpbnV4LXg2NC5ycG0=\">https://download.oracle.com/otn/java/jdk/8u281-b09/89d678f2be164786b292527658ca1605/jdk-8u281-linux-x64.rpm</span></p>\n</li>\n<li>\n<p>使用 xftpt 上传至 /home 目录里的用户文件夹下，我这里上传到 /home/honshen 目录下，<strong> 注意命令:  <code>rpm -ivh 文件名</code> </strong>:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /home/honshen</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">rpm</span> -ivh jdk-8u281-linux-x64.rpm</pre></td></tr></table></figure></li>\n<li>\n<p>安装完成后使用命令 <code>java -version</code>  查看版本号，如果控制台输出如下表明 java 已经安装成功</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen honshen<span class=\"token punctuation\">]</span><span class=\"token comment\"># java -version</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>java version <span class=\"token string\">\"1.8.0_281\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Java<span class=\"token punctuation\">(</span>TM<span class=\"token punctuation\">)</span> SE Runtime Environment <span class=\"token punctuation\">(</span>build <span class=\"token number\">1.8</span>.0_281-b09<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Java HotSpot<span class=\"token punctuation\">(</span>TM<span class=\"token punctuation\">)</span> <span class=\"token number\">64</span>-Bit Server VM <span class=\"token punctuation\">(</span>build <span class=\"token number\">25.281</span>-b09, mixed mode<span class=\"token punctuation\">)</span></pre></td></tr></table></figure></li>\n<li>\n<p>配置 java 的环境变量</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vim <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>profile</pre></td></tr></table></figure><p>然后按键盘的 i 键表示编辑文本，在文件的最后书写环境变量，书写完成后，按 esc 键然后输入 <code>:wq</code>  表示保存并退出</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-31_18-19-20.png\" alt=\"环境变量\" /></p>\n</li>\n<li>\n<p>让配置文件生效</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">source</span> /etc/profile</pre></td></tr></table></figure></li>\n<li>\n<p>查看防火墙开启了哪些端口，然后开启端口 80, 重启防火墙，如果是阿里云一定要修改安全组</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>firewall-cmd --list-ports</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>firewall-cmd --zone<span class=\"token operator\">=</span>public --add-port<span class=\"token operator\">=</span><span class=\"token number\">80</span>/tcp --permanent</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>systemctl restart firewalld.service</pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"解压缩安装\"><a class=\"anchor\" href=\"#解压缩安装\">#</a> 解压缩安装</h1>\n<ol>\n<li>\n<p>使用命令 cd /usr/local/src 进入到用户目录下</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /usr/local/src</pre></td></tr></table></figure></li>\n<li>\n<p>这时我们就在 src 目录下，在这个目录下我们安装 nodejs (这是一个压缩包), 并解压，如果提示找不到 wget 命令，就先使用命令:  <code>yum install -y wget </code> 去安装 wget</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wget</span> https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">tar</span> xvJf node-v10.15.3-linux-x64.tar.xz</pre></td></tr></table></figure></li>\n<li>\n<p>我们对解压后的文件夹更名，方便我们之后建立软连接</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mv</span> node-v10.15.3-linux-x64 nodejs</pre></td></tr></table></figure></li>\n<li>\n<p>建立软连接</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ln</span> -sf /usr/local/src/nodejs/bin/node /usr/local/bin/node</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">ln</span> -sf /usr/local/src/nodejs/bin/npm /usr/local/bin/npm</pre></td></tr></table></figure></li>\n<li>\n<p>配置环境变量</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'export PATH=/usr/local/nodejs/bin:<span class=\"token environment constant\">$PATH</span>'</span> <span class=\"token operator\">>></span> /etc/profile</pre></td></tr></table></figure></li>\n<li>\n<p>使环境变量生效</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">source</span> /etc/profile</pre></td></tr></table></figure></li>\n<li>\n<p>通过查看版本号检测 nodejs 是否安装成功</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>node -v</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">npm</span> -v</pre></td></tr></table></figure><p>如果 xshell 控制台上输出如下信息表面 nodejs 环境已经搭建好了，如果你使用的 nodejs 版本不一样那么控制台输出也不一样</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen src<span class=\"token punctuation\">]</span><span class=\"token comment\"># node -v</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>v15.7.0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen src<span class=\"token punctuation\">]</span><span class=\"token comment\"># npm -v</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">7.4</span>.3</pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"yum安装\"><a class=\"anchor\" href=\"#yum安装\">#</a> yum 安装</h1>\n<ol>\n<li>\n<p>检测 CentOs 版本，我的版本是 CentOS7, 如果版本不一样，命令也不一样，这里上 docker 官网: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvY2VudG9zLw==\">https://docs.docker.com/engine/install/centos/</span></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cat</span> /etc/redhat-release</pre></td></tr></table></figure></li>\n<li>\n<p>移除本地的 docker</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum remove docker <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>           docker-client <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>           docker-client-latest <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>           docker-common <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>           docker-latest <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>           docker-latest-logrotate <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>           docker-logrotate <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>           docker-engine</pre></td></tr></table></figure></li>\n<li>\n<p>在线安装命令 <code>yum -y intsall 包名</code> ，-y 表示所有提示都选择确定</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum <span class=\"token function\">install</span> -y yum-utils device-mapper-persistant-data lvm2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</pre></td></tr></table></figure></li>\n<li>\n<p>更新 yum 包索引</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum makecache fast</pre></td></tr></table></figure></li>\n<li>\n<p>安装 docker</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum -y <span class=\"token function\">install</span> docker-ce docker-ce-cli containerd.io</pre></td></tr></table></figure></li>\n<li>\n<p>启动 docker, 如果没有报错表启动成功</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl start docker</pre></td></tr></table></figure></li>\n<li>\n<p>查看 docker 是否启动成功，我们执行以下命令查看 docker 进程</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ps</span> -ef<span class=\"token operator\">|</span><span class=\"token function\">grep</span> docker</pre></td></tr></table></figure></li>\n<li>\n<p>运行 helloword, 执行以下命令 docker 会去官网上 pull 一个 helloworld, 当你在控制台看到 <code>Hello from Docker!</code>  已经成功了</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run hello-world</pre></td></tr></table></figure></li>\n</ol>\n",
            "tags": [
                "HEXO搭建个人博客",
                "Hexo",
                "博客",
                "服务器"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/02/06/Docker/%E7%AC%AC6%E7%AB%A0-Docker%E8%BF%9B%E9%98%B6%E4%B9%8BDockerCompose/",
            "url": "https://honshen.xyz/2021/02/06/Docker/%E7%AC%AC6%E7%AB%A0-Docker%E8%BF%9B%E9%98%B6%E4%B9%8BDockerCompose/",
            "title": "第6章-Docker进阶之DockerCompose",
            "date_published": "2021-02-06T04:20:45.000Z",
            "content_html": "<h1 id=\"dockercompose\"><a class=\"anchor\" href=\"#dockercompose\">#</a> DockerCompose</h1>\n",
            "tags": [
                "Docker基础及进阶",
                "笔记",
                "服务器",
                "docker"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/02/04/Docker/%E7%AC%AC4%E7%AB%A0-Docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86/",
            "url": "https://honshen.xyz/2021/02/04/Docker/%E7%AC%AC4%E7%AB%A0-Docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%8E%9F%E7%90%86/",
            "title": "第4章-Docker的镜像原理",
            "date_published": "2021-02-04T04:20:45.000Z",
            "content_html": "<h1 id=\"Docker镜像原理\"><a href=\"#Docker镜像原理\" class=\"headerlink\" title=\"Docker镜像原理\"></a>Docker镜像原理</h1><h2 id=\"联合文件系统\"><a href=\"#联合文件系统\" class=\"headerlink\" title=\"联合文件系统\"></a>联合文件系统</h2><p>​    UnionFS (联合文件系统）: Union文件系统( UnionFS ) 是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtualfilesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br>​    特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-02_21-51-16.png\" alt=\"文件系统\"></p>\n<p>​    docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>​    boots(boot fle system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。<br>​    roots(rot fle system)，在bootfs之上。包含的就是典型Linux系统中的/dev,/proc, /bin, /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如uBuntu , Centos等等。</p>\n<h1 id=\"镜像层和容器层\"><a href=\"#镜像层和容器层\" class=\"headerlink\" title=\"镜像层和容器层\"></a>镜像层和容器层</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-03_10-04-32.png\" alt=\"理解\"></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-03_10-08-01.png\" alt=\"分层\"></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-03_10-08-22.png\" alt=\"合并\"></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-03_10-12-54.png\" alt=\"镜像层\"></p>\n<h1 id=\"commit镜像\"><a href=\"#commit镜像\" class=\"headerlink\" title=\"commit镜像\"></a>commit镜像</h1><ul>\n<li><p>提交一个镜像</p>\n<pre><code class=\"shell\">docker commit #提交容器称为一个副本\ndocker commit -m=&quot;描述&quot; -a=&quot;作者&quot; 容器id 镜像名:[版本] #完整的提交一个镜像\n#例如:\ndocker commit -m=&quot;add webapps app&quot; -a=&quot;honshen&quot; 300e315adb2f tomcat01:1.0 </code></pre>\n</li>\n<li><p>执行上述命令后会生成一个tomcat01的镜像(版本号:1.0),以后我们可以直接使用修改后的镜像,这个镜像类似于虚拟机的快照</p>\n</li>\n</ul>\n",
            "tags": [
                "Docker基础及进阶",
                "笔记",
                "服务器",
                "docker"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/02/04/Docker/%E7%AC%AC5%E7%AB%A0-Docker%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7,File%E5%92%8C%E7%BD%91%E7%BB%9C/",
            "url": "https://honshen.xyz/2021/02/04/Docker/%E7%AC%AC5%E7%AB%A0-Docker%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7,File%E5%92%8C%E7%BD%91%E7%BB%9C/",
            "title": "第5章-Docker的数据卷,File和网络",
            "date_published": "2021-02-04T04:20:45.000Z",
            "content_html": "<h1 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h1><h2 id=\"为什么需要\"><a href=\"#为什么需要\" class=\"headerlink\" title=\"为什么需要?\"></a>为什么需要?</h2><ul>\n<li>数据存放在容器中,删除容器数据丢失–<strong>需求: 数据的可持久化</strong></li>\n<li>类似于mysql一样的数据库–<strong>需求: 数据存储在本地</strong></li>\n<li><strong>容器之间数据共享–容器产生的数据同步到本地</strong></li>\n</ul>\n<h2 id=\"实质\"><a href=\"#实质\" class=\"headerlink\" title=\"实质\"></a>实质</h2><ul>\n<li><p>将容器内的目录挂载到linux服务器上</p>\n</li>\n<li><p>容器的持久化和同步操作</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-03_11-06-43.png\" alt=\"挂载\"></p>\n</li>\n</ul>\n<h1 id=\"挂载数据卷\"><a href=\"#挂载数据卷\" class=\"headerlink\" title=\"挂载数据卷\"></a>挂载数据卷</h1><h2 id=\"指定路径挂载\"><a href=\"#指定路径挂载\" class=\"headerlink\" title=\"指定路径挂载\"></a>指定路径挂载</h2><ul>\n<li><p><code>docker run</code>的参数中加上<code>- v</code>,如下: </p>\n<pre><code class=\"shell\">docker run -it -v 主机目录:容器目录 -p 主机端口:容器端口 容器id</code></pre>\n<p>例如:  <code>docker run -it -v /home/mysql:/usr/mysql mysql /bin/bash </code>,这里将容器内/usr/mysql目录挂载到服务器的/home/mysql目录下</p>\n</li>\n<li><p>使用<code>docker inspect</code>查看卷是否挂载成功</p>\n<pre><code class=\"shell\">docker inspect 容器id</code></pre>\n<p>例如: <code>docker inspect 300e315adb2f</code>,控制台会输出其配置文件信息,其中字段<code>Mounts</code>中有一个对象其中记录了挂载信息</p>\n<pre><code class=\"json\">&quot;Mounts&quot;: [\n    &#123;\n        &quot;Type&quot;: &quot;bind&quot;, //挂载方式为绑定\n        &quot;Source&quot;: &quot;/home/mysql&quot;, //挂载的服务器目录\n        &quot;Destination&quot;: &quot;/home/msql&quot;, //挂载的容器目录\n        &quot;Mode&quot;: &quot;&quot;,\n        &quot;RW&quot;: &quot;true&quot;,\n        &quot;Propagation&quot;: &quot;private&quot;\n    &#125;\n]</code></pre>\n</li>\n</ul>\n<h2 id=\"具名挂载和匿名挂载\"><a href=\"#具名挂载和匿名挂载\" class=\"headerlink\" title=\"具名挂载和匿名挂载\"></a>具名挂载和匿名挂载</h2><ul>\n<li><h3 id=\"查看卷信息\"><a href=\"#查看卷信息\" class=\"headerlink\" title=\"查看卷信息\"></a>查看卷信息</h3><pre><code class=\"shell\">docker volume --help\nCommands:\n  create      Create a volume\n  inspect     Display detailed information on one or more volumes\n  ls          List volumes\n  prune       Remove all unused local volumes\n  rm          Remove one or more volumes</code></pre>\n</li>\n<li><h3 id=\"匿名挂载\"><a href=\"#匿名挂载\" class=\"headerlink\" title=\"匿名挂载\"></a>匿名挂载</h3><pre><code class=\"shell\">docker run -d -P --name 容器名 -v 路径 镜像</code></pre>\n<p>例如: <code>docker run -d -P --name nginx01 -v /ect/nginx nginx</code>,这里-v的参数只写了容器的路径,没有写主机的路径,这种挂载的卷名称为hashcode</p>\n<p>你可以使用<code>docker volume ls</code>查看本地挂载的卷,通过匿名挂载的卷名称是一串很长的hashcode,这些卷挂载于服务器的<code>/var/lib/docker/volumes/hashcode卷名称/_data</code>路径下,一般不建议使用匿名挂载</p>\n</li>\n<li><h3 id=\"具名挂载\"><a href=\"#具名挂载\" class=\"headerlink\" title=\"具名挂载\"></a>具名挂载</h3><pre><code class=\"shell\">docker run -d -P --name 容器名 -v 卷名称:路径 镜像</code></pre>\n<p>例如: <code>docker run -d -P --name nginx02 -v honshen:/ect/nginx nginx</code>,这里为挂载路径命名为honshen</p>\n<p>你可以使用<code>docker volume 卷名称</code>查看具名挂载的具体路径,例如: <code>docker volume honshen</code>可以查看到nginx02的挂载路径,一般docker的挂载路径为服务器的<code>/var/lib/docker/volumes/卷名称/_data</code>路径下</p>\n</li>\n</ul>\n<h2 id=\"修改卷权限\"><a href=\"#修改卷权限\" class=\"headerlink\" title=\"修改卷权限\"></a>修改卷权限</h2><ul>\n<li><p>在挂载时<code>-v 路径:ro</code>表示只读或<code>-v 路径:rw</code>表示可读可写</p>\n<pre><code class=\"shell\">docker run -d -P --name 容器名 -v 卷名称:路径:ro 镜像\ndocker run -d -P --name 容器名 -v 卷名称:路径:rw 镜像\ndocker run -d -P --name 容器名 -v 服务器路径:容器路径:ro 镜像\ndocker run -d -P --name 容器名 -v 服务器路径:容器路径:rw 镜像</code></pre>\n</li>\n<li><p>一旦使用ro修改为只读,容器对改卷没有操作权限,该卷只能通过宿主机(服务器去修改)</p>\n</li>\n</ul>\n<h1 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h1><ol>\n<li><p>docker下载mysql<code>docker pull mysql</code>最新版本,这里指定下载5.7版本</p>\n<pre><code class=\"shell\">docker pull mysql:5.7</code></pre>\n</li>\n<li><p>运行容器并挂载数据</p>\n<pre><code class=\"shell\">docker run -d -it -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=配置mysql初始密码 --name mysql01 mysql:5.7</code></pre>\n<pre><code class=\"shell\">[root@honshen home ]# docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v/home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSwORD=123456 --name mysql01 mysql:5.7</code></pre>\n<p>这里,我们启动mysql服务(端口是3306)并将mysql的数据和配置文件挂载到了服务器的/home/mysql下,接下来我们可以使用sqlyog远程连接mysql</p>\n</li>\n</ol>\n<h1 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h1><h2 id=\"初识Dockerfile\"><a href=\"#初识Dockerfile\" class=\"headerlink\" title=\"初识Dockerfile\"></a>初识Dockerfile</h2><ul>\n<li><p>dockerfile是用来构建docker镜像的构建文件</p>\n</li>\n<li><p>创建dockerfile,名字可以任意但文件名为建议Dockerfile</p>\n</li>\n<li><p>文件中命令大写!</p>\n</li>\n<li><p>使用<code>docker build</code>执行Dockerfile</p>\n<pre><code class=\"docker\">FROM centos\nVOLUME [&quot;容器挂载路径&quot;,&quot;容器挂载路径&quot;,...]\nCMD echo &quot;--end--&quot;\nCMD [&quot;/bin/bash&quot;]</code></pre>\n</li>\n<li><p>这种方式挂载出来是匿名挂载,你可以使用<code>docker inspect 容器id</code>查看镜像中的Mounts字段,这个对象里记录了卷挂载的服务器路径</p>\n</li>\n</ul>\n<h2 id=\"容器数据卷-1\"><a href=\"#容器数据卷-1\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h2><ul>\n<li><p>实现多个容器间的数据共享</p>\n<pre><code class=\"shell\">#启动一个容器\ndocker run -it --name 容器名称 -v 服务器路径:容器路径 /bin/bash 容器id</code></pre>\n<pre><code class=\"shell\">#启动第二个容器并与第一个共享数据\ndocker run -it --name 容器名称 --volumes-from 第一个容器名称 容器id</code></pre>\n</li>\n<li><p>共享的文件是互相拷贝的,删除其中一个容器另一个容器的数据不会丢失,数据卷的声明周期持续到没有容器使用为止,且一旦使用同步到了本地那么数据卷将不会消失</p>\n</li>\n</ul>\n<h2 id=\"Dockerfile构建镜像\"><a href=\"#Dockerfile构建镜像\" class=\"headerlink\" title=\"Dockerfile构建镜像\"></a>Dockerfile构建镜像</h2><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><ul>\n<li><p>每个保留关键字(命令)都是大写,代码从上到下顺序执行执行</p>\n</li>\n<li><p>#表示注释,每一行的命令都会创建一个新的镜像层并提交</p>\n<p><img data-src=\"https://img2020.cnblogs.com/blog/2030366/202006/2030366-20200630103737429-2119801149.png\" alt=\"镜像层\"></p>\n</li>\n</ul>\n<h3 id=\"命令集\"><a href=\"#命令集\" class=\"headerlink\" title=\"命令集\"></a>命令集</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>FROM</td>\n<td>基础镜像,一切从这里开始构建</td>\n</tr>\n<tr>\n<td>MAINTAINER</td>\n<td>镜像的作者: 姓名+邮箱</td>\n</tr>\n<tr>\n<td>RUN</td>\n<td>docker镜像构建时执行的命令</td>\n</tr>\n<tr>\n<td>ADD</td>\n<td>添加内容</td>\n</tr>\n<tr>\n<td>WORKDIR</td>\n<td>镜像的工作目录</td>\n</tr>\n<tr>\n<td>VOLUME</td>\n<td>挂载卷</td>\n</tr>\n<tr>\n<td>EXPOSE</td>\n<td>指定暴露端口</td>\n</tr>\n<tr>\n<td>CMD</td>\n<td>指定容器启动时运行的命令,只有最后一个会生效,可被替代</td>\n</tr>\n<tr>\n<td>ENTRYPOINT</td>\n<td>指定容器启动时运行的命令,可以追加命令</td>\n</tr>\n</tbody></table>\n<p>tips:CMD和ENTRYPOINT的区别: </p>\n<ul>\n<li>CMD:build成功后执行<code>docker run 镜像id</code>会执行CMD的命令相当于<code>docker run 镜像id CMD命令</code>,但是如果在<code>docker run 镜像id 参数</code>类似于<code>docker run 镜像id CMD命令+参数</code>会报错,如果想对CMD中的命令加参数,需要覆盖掉CMD命令,直接写<code>docker run 镜像id 命令+参数</code></li>\n<li>ENTRYPOINT: 执行<code>docker run 镜像id</code>会执行ENTRYPOINT的命令相当于<code>docker run 镜像id ENTRYPOINT命令</code>,但是如果在<code>docker run 镜像id 参数</code>类似于<code>docker run 镜像id ENTRYPOINT命令+参数</code>不会报错</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ONBUILD</td>\n<td>当构建一个被继承的dockerfile,这时会运行ONBUILD指令</td>\n</tr>\n<tr>\n<td>COPY</td>\n<td>将文件拷贝到镜像中</td>\n</tr>\n<tr>\n<td>ENV</td>\n<td>构建镜像设置环境变量</td>\n</tr>\n</tbody></table>\n<p><strong>dockerhub中很多镜像来源于一个基础镜像</strong></p>\n<pre><code class=\"dockerfile\">FROM scratch</code></pre>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/6870990-744e06b25e051ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp\" alt=\"dockerfile\"></p>\n<h3 id=\"制作centos\"><a href=\"#制作centos\" class=\"headerlink\" title=\"制作centos\"></a>制作centos</h3><pre><code class=\"dockerfile\">FROM centos\nMAINTAINER honshen&lt;1394948572@qq.com&gt;\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\nRUN yum -y install vim\nRUN yum -y install net-tools\n\nEXPOSE 80\nCMD echo $MYPATH\nCMD echo &quot;--end--&quot;\nCMD /bin/bash</code></pre>\n<ul>\n<li>运行dockerfile</li>\n</ul>\n<pre><code class=\"shell\">docker build -f 文件路径 -t 镜像名称:版本号 .</code></pre>\n<p><strong>注意命令最后有个英文字符点<code>.</code></strong></p>\n<h3 id=\"查看镜像构建历史\"><a href=\"#查看镜像构建历史\" class=\"headerlink\" title=\"查看镜像构建历史\"></a>查看镜像构建历史</h3><pre><code class=\"shell\">docker history 镜像id</code></pre>\n<h1 id=\"发布镜像\"><a href=\"#发布镜像\" class=\"headerlink\" title=\"发布镜像\"></a>发布镜像</h1><h2 id=\"发布到dockerhub\"><a href=\"#发布到dockerhub\" class=\"headerlink\" title=\"发布到dockerhub\"></a>发布到dockerhub</h2><ul>\n<li><p>dockerhub官网地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=\">https://hub.docker.com/</span></p>\n</li>\n<li><p>dockerhub注册地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWdpc3RyeS5odWIuZG9ja2VyLmNvbS8=\">https://registry.hub.docker.com/</span></p>\n</li>\n<li><p>登录到命令行登录dockerhub</p>\n<pre><code class=\"shell\">docker login -u 用户名 -p 密码</code></pre>\n</li>\n<li><p>发布到dockerhub</p>\n<pre><code class=\"shell\">docker push 作者/镜像名:版本号</code></pre>\n<p>例如: <code>docker push honshen/myCentos:1.0</code></p>\n</li>\n</ul>\n<h2 id=\"发布到阿里云镜像\"><a href=\"#发布到阿里云镜像\" class=\"headerlink\" title=\"发布到阿里云镜像\"></a>发布到阿里云镜像</h2><ul>\n<li><p>登录阿里云控制台找到容器镜像服务其中有镜像仓库</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-04_20-39-39.png\" alt=\"找到镜像仓库\"></p>\n</li>\n<li><p>镜像仓库下面是命名空间,首先我们创建一个命名空间–创建命名空间的按钮在网页的右上角</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-04_20-45-47.png\" alt=\"创建命名空间\"></p>\n</li>\n<li><p>接着打开镜像仓库我们点击创建镜像仓库</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-04_20-47-34.png\" alt=\"创建镜像仓库\"></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-04_20-47-56.png\" alt=\"仓库选择本地\"></p>\n</li>\n<li><p>使用阿里云镜像: 我们创建完仓库后点击仓库,这里有阿里云的官方操作,我们只需要复制代码即可</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-04_20-51-12.png\" alt=\"使用阿里云镜像\"></p>\n</li>\n</ul>\n<h2 id=\"docker全流程\"><a href=\"#docker全流程\" class=\"headerlink\" title=\"docker全流程\"></a>docker全流程</h2><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-05_11-06-40.jpg\" alt=\"全流程\"></p>\n<h1 id=\"docker网络\"><a href=\"#docker网络\" class=\"headerlink\" title=\"docker网络\"></a>docker网络</h1><h2 id=\"理解docker0\"><a href=\"#理解docker0\" class=\"headerlink\" title=\"理解docker0\"></a>理解docker0</h2><ul>\n<li><p>获取ip</p>\n<pre><code class=\"shell\">ip addr</code></pre>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-05_12-34-16.png\" alt=\"地址\"></p>\n</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li><p>安装docker后,docker会有一个网卡docker0(桥接模式),使用evth-pair技术</p>\n</li>\n<li><p>每启动一个docker容器,docker会给容器分配一个同网段的ip</p>\n<blockquote>\n<p>容器的网卡都是一对一对的<br>evth-pair是一对虚拟设备的接口,成对出现,一端连接协议,一端彼此相连,相当于桥梁连接各种虚拟设备</p>\n<p>因此容器和容器之间可以互相ping通</p>\n</blockquote>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-05_12-52-02.png\" alt=\"原理图\"></p>\n</li>\n<li><p>从图可知tomcat01和tomcat02通过docker0转发请求,docker0充当路由,在容器不指定网络的情况下是由docker0路由,docker0会给每个容器分配一个可用的ip保证其可以互相通信</p>\n</li>\n</ul>\n<h2 id=\"–link\"><a href=\"#–link\" class=\"headerlink\" title=\"–link\"></a>–link</h2><ul>\n<li><p>启动时命令<code>--link 容器名</code>与另一个容器互联</p>\n<pre><code class=\"shell\">docker run -d -P --name 容器名 --link 容器名 镜像名</code></pre>\n<p>例如: <code>docker run -d -P --name tomcat02 --link tomcat01 tomcat</code>这样将tomcat02和tomcat01联接,你可以尝试ping tomcat01 <code>docker exec -it tomcat02 ping tomcat01</code>你可以看到来自tomcat01的数据包,但是如果tomcat01启动时没有连接tomcat02则不能反向ping tomcat01的数据</p>\n</li>\n<li><p>查看配置</p>\n<pre><code class=\"shell\">docker exec -it 容器名 cat /etc/hosts</code></pre>\n<p>例如: <code>docker exec -it tomcat02 cat /etc/host</code>,你可以清楚的在此处看到tomcat02的hosts文件中直接将tomcat01的容器名映射到了内网地址下,但是如果你查看tomcat01的hosts文件你会发现这里没有对tomcat02的相关映射</p>\n</li>\n<li><p>不建议使用–link</p>\n</li>\n</ul>\n<h2 id=\"自定义网络\"><a href=\"#自定义网络\" class=\"headerlink\" title=\"自定义网络\"></a>自定义网络</h2><ul>\n<li>docker0不支持容器名访问</li>\n</ul>\n<h3 id=\"网络模式\"><a href=\"#网络模式\" class=\"headerlink\" title=\"网络模式\"></a>网络模式</h3><ul>\n<li>bridge: 桥接 (docker默认,自定义网络)</li>\n<li>none: 不配置网络</li>\n<li>host: 和宿主机共享网络</li>\n<li>container: 和容器网络互联(局限很大)</li>\n</ul>\n<h3 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h3><ul>\n<li><p>查看docker网络配置</p>\n<pre><code class=\"shell\">docker network ls #查看网络\ndocker network rm [NAME] #移除网络</code></pre>\n</li>\n<li><p>自定义网络</p>\n<pre><code class=\"shell\">docker network create --driver bridge --subnet 子网ip --gateway 网关 网络名\ndocker -d -P --name 容器名 --net 网络名 镜像名 #默认使用docker0也是就--net bridge</code></pre>\n<p>例如: <code>docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.169.0.1 mynet</code>,接着你可要使用命令<code>docker network ls</code>查看新建的网络,这里子网最大支持192.168.0.2~192.168.255.255,你也可以使用<code>docker network inspect 网络名</code>去查看某个网络名详细的网络配置</p>\n<p>这样自定义网络可以用于容器互联,这时即便没有使用–link也可以直接<code>docker exec -it tomcat02 ping tomcat01</code>或者<code>docker exec -it tomcat01 ping tomcat02</code></p>\n</li>\n</ul>\n<h2 id=\"网络连通\"><a href=\"#网络连通\" class=\"headerlink\" title=\"网络连通\"></a>网络连通</h2><ul>\n<li><p>当两个容器处于不同的网段时,直接<code>ping 容器名</code>会报错</p>\n</li>\n<li><p>尝试使一个容器直接连接到网络</p>\n<pre><code class=\"shell\">docker network connect 网络名 容器名</code></pre>\n<p>例如: <code>docker network connect tomcat03 mynet</code>如果tomcat03的网段与我们之前自定义的网段192.168不同我们通过这种方式使tomcat03能够访问到tomcat01和tomcat02,这时我们可以查看网络的连接配置<code>docker network inspect mynet</code>,这时可以看到docker直接将tomcat03加入到了tomcat01和tomcat02所在的网络也就是一个容器两个ip,tomcat03拥有了两个不同网段的ip地址</p>\n</li>\n</ul>\n",
            "tags": [
                "Docker基础及进阶",
                "笔记",
                "服务器",
                "docker"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/02/03/Docker/%E7%AC%AC3%E7%AB%A0-Docker%E9%83%A8%E7%BD%B2Nginx-Tomcat-ES+Kibana%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E6%9D%BFportainer/",
            "url": "https://honshen.xyz/2021/02/03/Docker/%E7%AC%AC3%E7%AB%A0-Docker%E9%83%A8%E7%BD%B2Nginx-Tomcat-ES+Kibana%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E6%9D%BFportainer/",
            "title": "第3章-Docker部署Nginx-Tomcat-ES+Kibana及可视化面板portainer",
            "date_published": "2021-02-03T04:20:45.000Z",
            "content_html": "<h1 id=\"Docker部署Nginx-Tomcat-ES-Kibana及可视化面板portainer\"><a href=\"#Docker部署Nginx-Tomcat-ES-Kibana及可视化面板portainer\" class=\"headerlink\" title=\"Docker部署Nginx-Tomcat-ES+Kibana及可视化面板portainer\"></a>Docker部署Nginx-Tomcat-ES+Kibana及可视化面板portainer</h1><h1 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h1><ol>\n<li><p>查看dockerHub上是否存在Nginx</p>\n<pre><code class=\"shell\">docker search nginx</code></pre>\n</li>\n<li><p>确认存在镜像后,下载nginx</p>\n<pre><code class=\"shell\">docker pull nginx</code></pre>\n</li>\n<li><p>下载完成后启动nginx</p>\n<pre><code class=\"shell\">docker run -d --name nginx01 -p 3344:80 nginx #以后台运行nginx 容器端口选择80,默认也是80映射到主机的3344端口,容器名为nginx01</code></pre>\n</li>\n<li><p>测试</p>\n<pre><code class=\"shell\">curl localhost:3344</code></pre>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-02_18-41-18.png\" alt=\"映射\"></p>\n</li>\n<li><p>查找nginx的配置文件</p>\n<pre><code class=\"shell\">whereis nginx</code></pre>\n</li>\n<li><p>修改配置文件</p>\n<pre><code class=\"shell\">#进入nginx文件夹,在这里你可以使用ls查看nginx的所有文件信息\ncd /etc/nginx</code></pre>\n</li>\n</ol>\n<h1 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h1><ol>\n<li><p>下载Tomcat</p>\n<pre><code class=\"shell\">docker pull tomcat:9.0 #下载tomcat9.0</code></pre>\n</li>\n<li><p>启动Tomcat</p>\n<pre><code class=\"shell\">docker run -d -p 3355:80 --name tomcat01 tomcat</code></pre>\n<p>问题:下载的tomcat能够执行linux命令少了,webapps文件夹里没有文件原因是阿里云的最小镜像,保证最小可运行环境,初始项目存在于webapps.dist目录中</p>\n</li>\n</ol>\n<h1 id=\"ES-Kibana\"><a href=\"#ES-Kibana\" class=\"headerlink\" title=\"ES+Kibana\"></a>ES+Kibana</h1><ol>\n<li><p>下载并启动</p>\n<pre><code class=\"shell\">docker run -d --name elasticsearch -net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.62</code></pre>\n<p>问题: elasticsearch启动之后消耗大量内存造成卡顿,可以使用命令<code>docker stats 容器id</code>查看cpu状态</p>\n</li>\n<li><p>设置内存限制启动,内存大小64m-512m之间</p>\n<pre><code class=\"shell\">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; e1asticsearch:7.6.2</code></pre>\n</li>\n</ol>\n<h1 id=\"Portainer可视化面板\"><a href=\"#Portainer可视化面板\" class=\"headerlink\" title=\"Portainer可视化面板\"></a>Portainer可视化面板</h1><ol>\n<li><p>下载安装</p>\n<pre><code class=\"shell\">docker run -d -p 8088:9000 \\\n--restart=always -v/var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre>\n</li>\n<li><p>访问通过主机ip和8088端口去访问portainer,8088端口需要你设置开放安全组</p>\n<p><code>http://主机公网ip:8088</code></p>\n</li>\n<li><p>第一次登陆portainer需要你配置一个用户及登录密码,并牢记</p>\n</li>\n</ol>\n",
            "tags": [
                "Docker基础及进阶",
                "笔记",
                "服务器",
                "docker"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/02/02/Docker/%E7%AC%AC2%E7%AB%A0-Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86/",
            "url": "https://honshen.xyz/2021/02/02/Docker/%E7%AC%AC2%E7%AB%A0-Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86/",
            "title": "第2章-Docker的常用命令集",
            "date_published": "2021-02-02T04:20:45.000Z",
            "content_html": "<h1 id=\"docker的常用命令集\"><a class=\"anchor\" href=\"#docker的常用命令集\">#</a> Docker 的常用命令集</h1>\n<h1 id=\"镜像基本命令\"><a class=\"anchor\" href=\"#镜像基本命令\">#</a> 镜像基本命令</h1>\n<ul>\n<li>\n<h2 id=\"查看本地主机上的镜像信息\"><a class=\"anchor\" href=\"#查看本地主机上的镜像信息\">#</a> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9pbWFnZXMv\">查看本地主机上的镜像信息</span></h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker images <span class=\"token comment\">#查看镜像</span></pre></td></tr></table></figure><h3 id=\"镜像信息\"><a class=\"anchor\" href=\"#镜像信息\">#</a> 镜像信息</h3>\n<table>\n<thead>\n<tr>\n<th>REPOSITORY</th>\n<th>TAG</th>\n<th>IMAGE ID</th>\n<th>CREATED</th>\n<th>SIZE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hello-world</td>\n<td>latest</td>\n<td>bf756fb1ae65</td>\n<td>13 months ago</td>\n<td>13.3kB</td>\n</tr>\n<tr>\n<td>仓库源</td>\n<td>镜像的标签</td>\n<td>镜像的 id</td>\n<td>镜像的创建时间</td>\n<td>镜像的大小</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"参数及作用\"><a class=\"anchor\" href=\"#参数及作用\">#</a> 参数及作用</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>--a , -a</td>\n<td>查看所有镜像</td>\n</tr>\n<tr>\n<td>--quite , -q</td>\n<td>只显示 id</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<h2 id=\"搜索镜像\"><a class=\"anchor\" href=\"#搜索镜像\">#</a> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=\">搜索镜像</span></h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker search 镜像 <span class=\"token comment\">#搜索镜像: docker search mysql</span></pre></td></tr></table></figure><p>亦可在 dockerHub 上搜索: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9zZWFyY2g/cT1teXNxbCZhbXA7dHlwZT1pbWFnZQ==\">mysql</span></p>\n<h3 id=\"参数及作用-2\"><a class=\"anchor\" href=\"#参数及作用-2\">#</a> 参数及作用</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>--filter , -f</td>\n<td>过滤信息，例如 --filter=STARS=3000 #过滤掉 stars 小于 3000 的</td>\n</tr>\n<tr>\n<td>--quite , -q</td>\n<td>只显示 id</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<h2 id=\"下载镜像\"><a class=\"anchor\" href=\"#下载镜像\">#</a> 下载镜像</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker pull 镜像 <span class=\"token comment\">#默认下载镜像的最新版本</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker pull 镜像<span class=\"token punctuation\">[</span>:tag<span class=\"token punctuation\">]</span> <span class=\"token comment\">#下载镜像的某个版本，该版本必须存在如: docker pull mysql:5.7</span></pre></td></tr></table></figure><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-02_10-52-46.png\" alt=\"下载镜像\" /></p>\n</li>\n<li>\n<h2 id=\"删除镜像\"><a class=\"anchor\" href=\"#删除镜像\">#</a> 删除镜像</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker rmi -f 镜像id或名称 <span class=\"token comment\">#删除镜像</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker rmi -f 镜像id 镜像id 镜像id <span class=\"token comment\">#删除多个镜像</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>docker rmi -f <span class=\"token variable\"><span class=\"token variable\">$(</span>docker images -aq<span class=\"token variable\">)</span></span> <span class=\"token comment\"># $(参数): 传递参数，删除所有镜像</span></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"容器命令\"><a class=\"anchor\" href=\"#容器命令\">#</a> 容器命令</h1>\n<ul>\n<li>\n<h2 id=\"运行镜像\"><a class=\"anchor\" href=\"#运行镜像\">#</a> 运行镜像</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run 镜像 <span class=\"token comment\">#启动镜像</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker run --help <span class=\"token comment\">#查看 run 命令的参数列表，很多这里不一一列举</span></pre></td></tr></table></figure><p><strong>参数及作用</strong></p>\n<table>\n<thead>\n<tr>\n<th>可选参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>--name=&quot;容器名称&quot;</td>\n<td>为容器设置名称用于区分容器</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>以后台方式运行，但是会暂停运行</td>\n</tr>\n<tr>\n<td>-it</td>\n<td>使用交互方式运行: docker run -it centos /bin/bash</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>指定端口，例如 -p 3344:80</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>随机指定端口</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-02_11-21-13.png\" alt=\"运行镜像\" /></p>\n<p><strong>docker 容器后台运行需要一个前台进程，docker 会停止后台应用</strong></p>\n</li>\n<li>\n<h2 id=\"查看运行的镜像\"><a class=\"anchor\" href=\"#查看运行的镜像\">#</a> 查看运行的镜像</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker <span class=\"token function\">ps</span> <span class=\"token comment\">#查看当前运行的镜像</span></pre></td></tr></table></figure><p><strong>参数及作用</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-a</td>\n<td>列出当前运行的容器以及历史运行过的容器</td>\n</tr>\n<tr>\n<td>-n = 数字</td>\n<td>显示最近创建的几个容器常用: -n=1</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>只显示容器 id 常用: docker ps -aq 列出所有容器 id</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<h2 id=\"退出容器\"><a class=\"anchor\" href=\"#退出容器\">#</a> 退出容器</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">exit</span> <span class=\"token comment\">#退出并关闭容器</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Ctrl + P + Q <span class=\"token comment\">#退出容器，但将容器放到后台继续运行</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"删除容器\"><a class=\"anchor\" href=\"#删除容器\">#</a> 删除容器</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker <span class=\"token function\">rm</span> 容器id <span class=\"token comment\">#删除容器，该容器不能再运行中否则无法删除</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker <span class=\"token function\">rm</span> -f 容器id <span class=\"token comment\">#强制删除容器包括运行中的容器</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>docker <span class=\"token function\">rm</span> -f <span class=\"token variable\"><span class=\"token variable\">$(</span>docker <span class=\"token function\">ps</span> -aq<span class=\"token variable\">)</span></span> <span class=\"token comment\">#强制删除全部容器</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>docker <span class=\"token function\">ps</span> -a -q<span class=\"token operator\">|</span><span class=\"token function\">xargs</span> docker <span class=\"token function\">rm</span> <span class=\"token comment\">#删除所有的容器</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"启动和停止容器\"><a class=\"anchor\" href=\"#启动和停止容器\">#</a> 启动和停止容器</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker start 容器id <span class=\"token comment\">#启动一个停止的容器</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker restart 容器id <span class=\"token comment\">#重启一个容器</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>docker stop 容器id <span class=\"token comment\">#停止一个正在运行的容器</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>docker <span class=\"token function\">kill</span> 容器id <span class=\"token comment\">#强制停止一个正在运行的容器</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">#docker 容器后台运行需要一个前台进程，docker 会停止后台应用</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"进入容器\"><a class=\"anchor\" href=\"#进入容器\">#</a> 进入容器</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker <span class=\"token builtin class-name\">exec</span> -it 容器id /bin/bash <span class=\"token comment\">#进入 ring 器后开启一个新的终端，能够在终端里进行操作</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker attach 容器id <span class=\"token comment\">#进入正在运行容器的终端，不会开启新的进程</span></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"日志\"><a class=\"anchor\" href=\"#日志\">#</a> 日志</h1>\n<ul>\n<li>\n<h2 id=\"查看日志\"><a class=\"anchor\" href=\"#查看日志\">#</a> 查看日志</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker logs -f -t --tail 数字 容器id <span class=\"token comment\">#查看某个容器的多少条日志信息</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker logs -tf <span class=\"token comment\">#查看全部日志</span></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"进程\"><a class=\"anchor\" href=\"#进程\">#</a> 进程</h1>\n<ul>\n<li>\n<h2 id=\"查看docker容器内部进程\"><a class=\"anchor\" href=\"#查看docker容器内部进程\">#</a> 查看 docker 容器内部进程</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker <span class=\"token function\">top</span> 容器id <span class=\"token comment\">#查看容器的内部进程</span></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"拷贝\"><a class=\"anchor\" href=\"#拷贝\">#</a> 拷贝</h1>\n<ul>\n<li>\n<h2 id=\"拷贝文件\"><a class=\"anchor\" href=\"#拷贝文件\">#</a> 拷贝文件</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker <span class=\"token function\">cp</span> 容器id:容器内路径 主机路径 <span class=\"token comment\">#将容器内的文件拷贝到主机，例如:docker cp abcd:/home/test.txt/home 这里将容器里 /home/test.txt 拷贝到主机的 /home 路径下</span></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"元数据\"><a class=\"anchor\" href=\"#元数据\">#</a> 元数据</h1>\n<ul>\n<li>\n<h2 id=\"查看镜像的元数据\"><a class=\"anchor\" href=\"#查看镜像的元数据\">#</a> 查看镜像的元数据</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker inspect 容器id <span class=\"token comment\">#查看容器的元数据</span></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"帮助命令\"><a class=\"anchor\" href=\"#帮助命令\">#</a> 帮助命令</h1>\n<ul>\n<li>\n<h2 id=\"查看版本号\"><a class=\"anchor\" href=\"#查看版本号\">#</a> 查看版本号</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker version</pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"查看docker系统详细信息\"><a class=\"anchor\" href=\"#查看docker系统详细信息\">#</a> 查看 docker 系统详细信息</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker info</pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"查看与docker命令有关的帮助\"><a class=\"anchor\" href=\"#查看与docker命令有关的帮助\">#</a> 查看与 docker 命令有关的帮助</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker 命令 --help <span class=\"token comment\">#</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"查看docker的全部命令\"><a class=\"anchor\" href=\"#查看docker的全部命令\">#</a> 查看 docker 的全部命令</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker --help</pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"这里放上docker的官网命令帮助文档\"><a class=\"anchor\" href=\"#这里放上docker的官网命令帮助文档\">#</a> 这里放上 docker 的官网命令帮助文档</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9ydW4v\">https://docs.docker.com/engine/reference/run/</span></p>\n</li>\n</ul>\n",
            "tags": [
                "Docker基础及进阶",
                "笔记",
                "服务器",
                "docker"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/02/01/Hexo/%E7%AC%AC4%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/",
            "url": "https://honshen.xyz/2021/02/01/Hexo/%E7%AC%AC4%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/",
            "title": "第4章-服务器环境搭建和博客部署",
            "date_published": "2021-02-01T05:12:45.000Z",
            "content_html": "<h1 id=\"第4章-服务器环境搭建和博客部署\"><a class=\"anchor\" href=\"#第4章-服务器环境搭建和博客部署\">#</a> 第 4 章 - 服务器环境搭建和博客部署</h1>\n<h1 id=\"连接远程服务器\"><a class=\"anchor\" href=\"#连接远程服务器\">#</a> 连接远程服务器</h1>\n<blockquote>\n<p>我们通过 XShell 连接到远程服务器，<strong> 需要以 root 用户登录</strong>，登录成功后控制台输出如下：我们需要切换到 /usr/local/src 目录下去部署 nodejs</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>WARNING<span class=\"token operator\">!</span> The remote SSH server rejected X11 forwarding request.</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Last login: Fri Jan <span class=\"token number\">29</span> <span class=\"token number\">19</span>:45:56 <span class=\"token number\">2021</span> from </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Welcome to Alibaba Cloud Elastic Compute Service <span class=\"token operator\">!</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen ~<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span></pre></td></tr></table></figure></blockquote>\n<h1 id=\"nodejs部署\"><a class=\"anchor\" href=\"#nodejs部署\">#</a> nodejs 部署</h1>\n<blockquote>\n<p>使用命令 cd /usr/local/src 进入到用户目录下</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /usr/local/src</pre></td></tr></table></figure><p>这时我们就在 src 目录下，在这个目录下我们安装 nodejs (这是一个压缩包), 并解压，如果提示找不到 wget 命令，就先使用命令:  <code>yum install -y wget </code> 去安装 wget</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wget</span> https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">tar</span> xvJf node-v10.15.3-linux-x64.tar.xz</pre></td></tr></table></figure><p>我们对解压后的文件夹更名，方便我们之后建立软连接</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mv</span> node-v10.15.3-linux-x64 nodejs</pre></td></tr></table></figure><p>建立软连接</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ln</span> -sf /usr/local/src/nodejs/bin/node /usr/local/bin/node</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">ln</span> -sf /usr/local/src/nodejs/bin/npm /usr/local/bin/npm</pre></td></tr></table></figure><p>配置环境变量</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'export PATH=/usr/local/nodejs/bin:<span class=\"token environment constant\">$PATH</span>'</span> <span class=\"token operator\">>></span> /etc/profile</pre></td></tr></table></figure><p>使环境变量生效</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">source</span> /etc/profile</pre></td></tr></table></figure><p>通过查看版本号检测 nodejs 是否安装成功</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>node -v</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">npm</span> -v</pre></td></tr></table></figure><p><strong>如果 xshell 控制台上输出如下信息表面 nodejs 环境已经搭建好了，如果你使用的 nodejs 版本不一样那么控制台输出也不一样</strong></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen src<span class=\"token punctuation\">]</span><span class=\"token comment\"># node -v</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>v15.7.0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen src<span class=\"token punctuation\">]</span><span class=\"token comment\"># npm -v</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">7.4</span>.3</pre></td></tr></table></figure></blockquote>\n<h1 id=\"部署博客\"><a class=\"anchor\" href=\"#部署博客\">#</a> 部署博客</h1>\n<blockquote>\n<p>我们利用 xftp 将之前搭建的个人博客上传到服务器的 /home 目录下，在此之前，我们先将博客文件复制到桌面，然后进入博客文件夹删除里面的 <code>node_modules</code>  文件夹，这个里面存放的都是一些依赖且文件体积较大，直接上传会浪费不少时间，删除完成后我们将博客文件夹上传到服务器</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_17-12-32.png\" alt=\"上传文件夹\" /></p>\n<p>接下来我们使用 XShell 进入到这个博客文件夹，并将之前删除的依赖重新安装，这里我们使用淘宝的镜像下载依赖怎样会快很多～</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /home/hongsheng-xu</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">npm</span> config <span class=\"token builtin class-name\">set</span> registry https://registry.npm.taobao.org</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">npm</span> i</pre></td></tr></table></figure><p>在服务器上安装 nohup 和 hexo</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum <span class=\"token function\">install</span> coreutils</pre></td></tr></table></figure><p>编辑配置，如图在环境变量后加上 usr/bin:, 编辑完后按 esc 键，然后输入:  <code>:wq</code> , 这样就修改完成</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">vi</span> ~/.bash_profile</pre></td></tr></table></figure><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-05_21-44-19.png\" alt=\"配置\" /></p>\n<p>使配置生效，并检查 nohup 的版本号验证是否安装成功，同理如果控制台输出了 nohup 的版本号表明安装成功</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">source</span> ~/.bash_profile</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">nohup</span> --version</pre></td></tr></table></figure><p>接下来我们安装 hexo 并且启动服务</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">npm</span> <span class=\"token function\">install</span> hexo-cli -g</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">nohup</span> hexo s -p <span class=\"token number\">80</span> <span class=\"token operator\">&amp;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">exit</span></pre></td></tr></table></figure><p>看到控制台输出如下表明成功:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen hongsheng-xu<span class=\"token punctuation\">]</span><span class=\"token comment\"># nohup: ignoring input and appending output to ‘nohup.out’</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">exit</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">logout</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>There are stopped jobs.</pre></td></tr></table></figure><p>这里你可以通过 http:// 服务器公网 ip / 或者通过域名去查看部署的代码，举个栗子:</p>\n<p>我部署的博客空间: <a href=\"http://honshen.xyz\">http://honshen.xyz</a></p>\n<p>也可以通过公网 ip 访问: <span class=\"exturl\" data-url=\"aHR0cDovLzguMTMxLjYyLjQ4Lw==\">http://8.131.62.48/</span></p>\n</blockquote>\n",
            "tags": [
                "HEXO搭建个人博客",
                "Hexo",
                "博客",
                "服务器"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/02/01/Docker/%E7%AC%AC1%E7%AB%A0-Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "https://honshen.xyz/2021/02/01/Docker/%E7%AC%AC1%E7%AB%A0-Docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "第1章-Docker安装部署及阿里云加速服务的使用",
            "date_published": "2021-02-01T04:20:45.000Z",
            "content_html": "<h1 id=\"docker安装部署及阿里云加速服务的使用\"><a class=\"anchor\" href=\"#docker安装部署及阿里云加速服务的使用\">#</a> Docker 安装部署及阿里云加速服务的使用</h1>\n<h1 id=\"docker简介\"><a class=\"anchor\" href=\"#docker简介\">#</a> Docker 简介</h1>\n<h2 id=\"docker官网-httpswwwdockercom\"><a class=\"anchor\" href=\"#docker官网-httpswwwdockercom\">#</a> Docker 官网: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=\">https://www.docker.com/</span></h2>\n<h2 id=\"docker文档-httpsdocsdockercomget-startedoverview\"><a class=\"anchor\" href=\"#docker文档-httpsdocsdockercomget-startedoverview\">#</a> Docker 文档: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZ2V0LXN0YXJ0ZWQvb3ZlcnZpZXcv\">https://docs.docker.com/get-started/overview/</span></h2>\n<h2 id=\"docker与虚拟机容器化技术\"><a class=\"anchor\" href=\"#docker与虚拟机容器化技术\">#</a> Docker 与虚拟机 (容器化技术)</h2>\n<ul>\n<li>虚拟机需要虚拟硬件，完整的操作系统，然后才能安装运行软件</li>\n<li>docker 容器内的应用直接运行在宿主机，应用 + 环境即可部署</li>\n<li>容器之间互相隔离互不影响，有独立的文件系统</li>\n<li><strong>DevOps (开发，运维): 更快的交付和部署 -- 更便捷的升级和扩容 -- 更简单的系统运维 -- 更高效的计算资源利用</strong></li>\n</ul>\n<h2 id=\"docker基本组成\"><a class=\"anchor\" href=\"#docker基本组成\">#</a> Docker 基本组成</h2>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_19-43-37.png\" alt=\"docker基本组成\" /></p>\n<ul>\n<li>镜像 (image)\n<ul>\n<li>类似模板，可以通过镜像创建多个容器服务 -- 最终项目运行在容器中</li>\n</ul>\n</li>\n<li>容器 (container)\n<ul>\n<li>通过镜像创建，可以独立运行一个或一组应用，基本命令：启动，停止，删除</li>\n</ul>\n</li>\n<li>仓库 (repository)\n<ul>\n<li>存放仓库的地方</li>\n<li>分为私有仓库和公有仓库，默认源为国外需要配置</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"docker安装\"><a class=\"anchor\" href=\"#docker安装\">#</a> Docker 安装</h1>\n<h2 id=\"环境准备\"><a class=\"anchor\" href=\"#环境准备\">#</a> 环境准备</h2>\n<ul>\n<li>\n<p>Linux 服务器 CentOS7, 你可以使用命令 <code>cat /etc/os-release</code>  来查看当前系统的版本</p>\n</li>\n<li>\n<p>XShell 进行远程连接，使用 <code>uname -r</code>  查看系统内核，控制台输出 <code>3.10.0-514.26.2.el7.x86_64</code> , 需要系统内核是 <code>3.10</code>  及以上的环境</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">uname</span> -r</pre></td></tr></table></figure></li>\n<li>\n<p>这里放上一篇 Docker 在 linux 的安装官方文档: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwv\">https://docs.docker.com/engine/install/</span>, 你亦可在 docker 官网找到其他操作系统的安装，这里放上其他操作系统的安装文档: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZ2V0LWRvY2tlci8=\">https://docs.docker.com/get-docker/</span></p>\n</li>\n</ul>\n<h2 id=\"安装docker引擎\"><a class=\"anchor\" href=\"#安装docker引擎\">#</a> 安装 Docker 引擎</h2>\n<ol>\n<li>\n<p>移除本地的 docker</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum remove docker <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>           docker-client <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>           docker-client-latest <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>           docker-common <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>           docker-latest <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>           docker-latest-logrotate <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>           docker-logrotate <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>           docker-engine</pre></td></tr></table></figure></li>\n<li>\n<p>在线安装：命令 <code>yum -y intsall 包名</code> ，-y 表示所有提示都选择确定，这里我们不使用官方推荐的镜像，我们选择阿里云镜像，这样的下载速度更快</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum <span class=\"token function\">install</span> -y yum-utils device-mapper-persistant-data lvm2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</pre></td></tr></table></figure></li>\n<li>\n<p>更新：使用命令更新 yum 包索引</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum makecache fast</pre></td></tr></table></figure></li>\n<li>\n<p>安装: docker 在线安装</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum -y <span class=\"token function\">install</span> docker-ce docker-ce-cli containerd.io</pre></td></tr></table></figure></li>\n<li>\n<p>查看：安装完成后，我们可以使用命令去查看 docker 是否安装成功，当控制台输出 docker 版本后表面安装成功</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker version</pre></td></tr></table></figure></li>\n<li>\n<p>启动：使用命令启动 docker, 如果没有报错表启动成功</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl start docker</pre></td></tr></table></figure></li>\n<li>\n<p>测试：运行 helloword, 执行以下命令 docker 会去官网上 pull 一个 helloworld, 当你在控制台看到 <code>Hello from Docker!</code>  已经成功了</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker run hello-world</pre></td></tr></table></figure><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_16-50-19.png\" alt=\"拉取hello-word\" /></p>\n</li>\n<li>\n<p>镜像：使用命令 <code>docker images</code>  查看下载的 hello-word 镜像</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker images</pre></td></tr></table></figure><p>控制台输出，其中有一个是项目是 hello-word, 它是 docker 从远程仓库 pull 来的:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@honshen ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker images</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>hello-world   latest    bf756fb1ae65   <span class=\"token number\">13</span> months ago   <span class=\"token number\">13</span>.3kB</pre></td></tr></table></figure></li>\n<li>\n<p>卸载: (1) 卸载依赖 (2) 删除资源:  <code>/var/lib/docker</code> docker 的默认工作路径</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 1、卸载依赖</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>yum remove docker-ce docker-ce-cli containerd.io</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#2、删除资源</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">rm</span> -rf /var/lib/docker</pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"阿里云镜像加速\"><a class=\"anchor\" href=\"#阿里云镜像加速\">#</a> 阿里云镜像加速</h1>\n<ol>\n<li>\n<p>阿里云: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS8=\">https://www.aliyun.com/</span>  需要先登录，然后进入到控制台，在产品与服务里选择容器镜像服务，如果你是第一次使用需要按照阿里云的引导设置一个登陆密码</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_17-01-08.png\" alt=\"镜像服务\" /></p>\n</li>\n<li>\n<p>在阿里云的镜像中心找到镜像加速器，复制里面的加速器地址即可这是免费的，<strong> 注：每一个账号的加速地址都不一样！！！</strong></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_17-11-44.png\" alt=\"镜像加速地址\" /></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_17-15-07.png\" alt=\"操作文档\" /></p>\n</li>\n<li>\n<p>配置使用:</p>\n<ol>\n<li>创建一个 docker 的配置目录，<strong> 如果你加上 sudo 报错了且是 root 用户可以执行以下命令</strong></li>\n</ol>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> -p /etc/docker</pre></td></tr></table></figure><ol start=\"2\">\n<li>\n<p>修改配置文件</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">tee</span> /etc/docker/daemon.json <span class=\"token operator\">&lt;&lt;-</span><span class=\"token string\">'EOF'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token string\">\"registry-mirrors\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"个人加速地址\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  EOF</pre></td></tr></table></figure></li>\n<li>\n<p>重启服务</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl daemon-reload</pre></td></tr></table></figure></li>\n<li>\n<p>重启 docker</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl restart docker</pre></td></tr></table></figure></li>\n<li>\n<p>至此阿里云镜像已经配置完毕</p>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"docker底层原理\"><a class=\"anchor\" href=\"#docker底层原理\">#</a> Docker 底层原理</h1>\n<ul>\n<li>\n<p>docker 运行时流程图</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_18-35-40.png\" alt=\"docker运行时流程图\" /></p>\n</li>\n<li>\n<p>docker 是一个 client-server 结构的系统，docker 的守护进程运行在主机上，通过 Socket 从客户端访问</p>\n</li>\n<li>\n<p>dockerServer 接收 dockerClient 的指令并执行</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_18-43-17.png\" alt=\"docker运行时\" /></p>\n</li>\n<li>\n<p>为什么 docker 比虚拟机快？</p>\n<p>下图可以说明:</p>\n<p>​\t(1) docker 比虚拟机有更少的抽象层</p>\n<p>​\t(2) docker 使用宿主机的内核</p>\n<p>当新建容器时，docker 不需要像虚拟机一样加载内核 CentOS (分钟), 直接利用宿主机的操作系统 (秒), 避免引导</p>\n<p><img data-src=\"https://ucc.alicdn.com/pic/developer-ecology/f70eb5d1e0594c9694080ab0a17a1e99.png\" alt=\"docker比虚拟快\" /><br />\n<img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-02-01_19-26-37.png\" alt=\"docker比虚拟机快\" /></p>\n</li>\n</ul>\n",
            "tags": [
                "Docker基础及进阶",
                "笔记",
                "docker"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/01/31/Hexo/%E7%AC%AC3%E7%AB%A0-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8(%E5%9F%BA%E4%BA%8ECentOS7)/",
            "url": "https://honshen.xyz/2021/01/31/Hexo/%E7%AC%AC3%E7%AB%A0-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8(%E5%9F%BA%E4%BA%8ECentOS7)/",
            "title": "第3章-Linux服务器的使用(基于CentOS7)",
            "date_published": "2021-01-31T05:12:45.000Z",
            "content_html": "<h1 id=\"linux服务器的使用基于centos7-配合阿里云\"><a class=\"anchor\" href=\"#linux服务器的使用基于centos7-配合阿里云\">#</a> Linux 服务器的使用 (基于 centOS7)-- 配合阿里云</h1>\n<h1 id=\"xshell和xftp的下载\"><a class=\"anchor\" href=\"#xshell和xftp的下载\">#</a> XShell 和 Xftp 的下载</h1>\n<ul>\n<li>XShell 官网下载地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly94c2hlbGwuZW4uc29mdG9uaWMuY29tLw==\">https://xshell.en.softonic.com/</span></li>\n<li>Xftp 官网下载地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmV0c2FyYW5nLmNvbS96aC94ZnRwLw==\">https://www.netsarang.com/zh/xftp/</span></li>\n</ul>\n<h1 id=\"xshell登录\"><a class=\"anchor\" href=\"#xshell登录\">#</a> XShell 登录</h1>\n<ol>\n<li>\n<p>新建远程连接，点击右上角新建按钮</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_17-29-30.png\" alt=\"新建远程连接\" /></p>\n</li>\n<li>\n<p>在弹出的新建窗口中，输入自已服务器的名称 (可以是任意名称), 然后选择协议，一般云服务器的协议是 SSH, 公网 IP 可以去阿里云找到服务器的实例查看这里以阿里云轻量服务器为例，填入服务器 ip 后可以点击连接，如果你没有服务器，可以在阿里云或者腾讯云，百度云选购一台，一般来说学生服务器大概在 100~200yuan 一年:</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_17-51-25.png\" alt=\"寻找公网ip\" /></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_17-34-56.png\" alt=\"新建会话\" /></p>\n</li>\n<li>\n<p>连接服务器，先修改服务器密码</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_17-58-56.png\" alt=\"修改密码\" /></p>\n</li>\n<li>\n<p>回到 XShell 链接服务器，选择接受来自服务器的 ssh 秘钥</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_17-56-25.png\" alt=\"登录名为root\" /></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_17-57-57.png\" alt=\"输入密码\" /></p>\n<ul>\n<li>XShell 控制台输出如下表明连接成功</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Welcome to Alibaba Cloud Elastic Compute Service <span class=\"token operator\">!</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@iz2zeg6qs3stnlr0awniwwz ~<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"xftp使用\"><a class=\"anchor\" href=\"#xftp使用\">#</a> xftp 使用</h1>\n<ul>\n<li>点击 xshell 上方的图标进入 xftp, 或者直接进入 xftp, 打开后如下</li>\n</ul>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_18-09-40.png\" alt=\"打开zftp\" /><br />\n<img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_18-14-43.png\" alt=\"打开xftp\" /></p>\n<h1 id=\"服务器文件信息\"><a class=\"anchor\" href=\"#服务器文件信息\">#</a> 服务器文件信息</h1>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-29_12-48-03.png\" alt=\"服务器文件\" /></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-29_13-00-34.png\" alt=\"绪\" /></p>\n<h1 id=\"xshell命令\"><a class=\"anchor\" href=\"#xshell命令\">#</a> XShell 命令</h1>\n<p><strong>linux 中没有错误就代表操作成功</strong></p>\n<ul>\n<li>\n<h2 id=\"清屏\"><a class=\"anchor\" href=\"#清屏\">#</a> 清屏</h2>\n<pre><code class=\"language-shelll\">clear\n</code></pre>\n</li>\n<li>\n<h2 id=\"关机\"><a class=\"anchor\" href=\"#关机\">#</a> 关机</h2>\n</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sync</span> <span class=\"token comment\"># 将数据由内存同步到硬盘中。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">shutdown</span> <span class=\"token comment\">#关机指令，你可以 man shutdown 来看一下帮助文档。例如你可以运行如下命令关机:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">shutdown</span> -h <span class=\"token number\">10</span> <span class=\"token comment\">#这个命令告诉大家，计算机将在 10 分钟后关机</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">shutdown</span> -h now <span class=\"token comment\">#立马关机</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">shutdown</span> -h <span class=\"token number\">20</span>:25 <span class=\"token comment\">#系统会在今天 20:25 关机</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">shutdown</span> -h +10 <span class=\"token comment\"># 十分钟后关机</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">shutdown</span> -r now <span class=\"token comment\">#系统立马重启</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">shutdown</span> -r +10 <span class=\"token comment\"># 系统十分钟后重启</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">reboot</span> <span class=\"token comment\">#就是重启，等同于 shutdown -r now</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">halt</span> <span class=\"token comment\">#关闭系统，等同于 shutdown -h now 和 poweroff</span></pre></td></tr></table></figure><ul>\n<li>\n<h2 id=\"文件列表查看\"><a class=\"anchor\" href=\"#文件列表查看\">#</a> 文件列表查看</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ls</span> <span class=\"token comment\">#查看当前目录下的文件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># -a 参数表示查看全部的文件，包含隐藏文件</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># -l 参数列出全部的文件包含文件属性和权限，没有隐藏文件</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#Linux 命令可以组合使用</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">ls</span> / <span class=\"token comment\">#查看根目录下的文件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">ls</span> -ll <span class=\"token comment\">#列表查看当前目录下的文件</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">ls</span> -al <span class=\"token comment\">#列表查看全部文件 (含隐藏文件)</span></pre></td></tr></table></figure><p>文件属性，通过 ls -al 列出文件的属性</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-29_15-48-46.png\" alt=\"文件权限\" /></p>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>属主权限</th>\n<th>属组权限</th>\n<th>其他用户权限</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d: 目录文件</td>\n<td>r (读) w (写) x (执行)</td>\n<td>r (读) w (写) x (执行)</td>\n<td>r (读) w (写) x (执行)</td>\n</tr>\n<tr>\n<td>l: 链接文件</td>\n<td>rwx (可读写执行)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-: 文件</td>\n<td>---(不可读写执行)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>b: 随机存储设备</td>\n<td>r-x (可读执行)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>c: 一次性读取装置</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<h2 id=\"修改文件属性\"><a class=\"anchor\" href=\"#修改文件属性\">#</a> 修改文件属性</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">chgrp</span> -R 属组名 文件名/文件夹名 <span class=\"token comment\"># chgrp -R root www 将 www 属组改为 root</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">chown</span> -R 属主名 文件名/文件夹名 <span class=\"token comment\"># chown -R root www 将 www 属主改为 root</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">chmod</span> -R xyz 文件/文件名</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>r:4 w:2 x:1 -:0</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>属主: <span class=\"token assign-left variable\">rwx</span><span class=\"token operator\">=</span><span class=\"token number\">4</span>+2+1<span class=\"token operator\">=</span><span class=\"token number\">7</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>属组: <span class=\"token assign-left variable\">rwx</span><span class=\"token operator\">=</span><span class=\"token number\">7</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>其他用户 ---<span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">chmod</span> <span class=\"token number\">777</span> 文件名 <span class=\"token comment\">#将一个文件属性修改为可读可写可执行，对所有用户有效赋予最高权限</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"文件内容查看\"><a class=\"anchor\" href=\"#文件内容查看\">#</a> 文件内容查看</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cat</span> 文件名 <span class=\"token comment\">#从第一行开始显示</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">tac</span> 文件名 <span class=\"token comment\">#从最后一行倒着显示</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">nl</span> 文件名 <span class=\"token comment\">#显示时输出行号</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">more</span> 文件名 <span class=\"token comment\">#一页一页的显示，空格键翻页，enter 向下翻一行，q 键退出</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">less</span> 文件名 <span class=\"token comment\">#比 more 更好，能往前翻页，键盘的上下键代表翻页，enter 翻一行，到文件结束按下 q 键退出，输入字符 / 字符串查找 / 后的字符串在文件中的所有位置 (向下查询), 使用？字符串向下查找，例: /set (查找此页及后的所有 set) ?set (查找此页及前的 set 字符) n 表示查找下一个，N 表示查找上一个</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">head</span> -n <span class=\"token number\">20</span> 文件名 <span class=\"token comment\">#只看头 20 行</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">tail</span> -n <span class=\"token number\">20</span> 文件名 <span class=\"token comment\">#只看尾 20 行</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">man</span> <span class=\"token punctuation\">[</span>命令<span class=\"token punctuation\">]</span> <span class=\"token comment\">#man cp 查看 cp 的使用文档</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">#cat /etc/passwd 账号密码信息</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#cat /etc/shadow 密码信息都是经过加密的</span></pre></td></tr></table></figure><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-29_19-06-20.png\" alt=\"密码\" /></p>\n</li>\n<li>\n<h2 id=\"切换目录\"><a class=\"anchor\" href=\"#切换目录\">#</a> 切换目录</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> 文件夹名 <span class=\"token comment\">#进入文件夹:cd usr</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> 绝对路径 <span class=\"token comment\">#切换到该路径:cd /usr/local/src, 其中:cd / 切换到根目录，cd ~ 切换到 /root</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">cd</span> 相对路径 <span class=\"token comment\">#切到该路径下的目录: cd ./usr/</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">..</span> <span class=\"token comment\">#返回上一级</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">..</span>/<span class=\"token comment\">#返回上一级目录</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token builtin class-name\">pwd</span> <span class=\"token comment\"># 查看当前目录</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"删除文件\"><a class=\"anchor\" href=\"#删除文件\">#</a> 删除文件</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">rm</span> 文件名 <span class=\"token comment\">#删除文件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>-f 忽略不存在的文件,不会出现警告强制删除</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-r 递归删除目录</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">rm</span> -rf / <span class=\"token comment\">#删库跑路！</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">rm</span> -rf 文件夹 <span class=\"token comment\">#删除文件夹下的所有文件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">rmdir</span> 文件夹 <span class=\"token comment\">#删除为空的文件夹</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">rmdir</span> -p 文件夹 <span class=\"token comment\">#删除文件夹包含里面的内容</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"创建文件\"><a class=\"anchor\" href=\"#创建文件\">#</a> 创建文件</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> 文件夹名 <span class=\"token comment\">#创建文件夹</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">mkdir</span> 文件夹1/文件夹2/文件夹3 <span class=\"token comment\">#在当前目录下创建文件夹 1, 文件夹 1 下创建文件夹 2, 文件夹 2 下创建文件夹 3</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"复制文件\"><a class=\"anchor\" href=\"#复制文件\">#</a> 复制文件</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cp</span> 文件路径1/文件名 文件路径2 <span class=\"token comment\">#将文件从文件路径 1 拷贝到文件路径 2</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"移动文件\"><a class=\"anchor\" href=\"#移动文件\">#</a> 移动文件</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mv</span> 文件夹或文件名 文件路径 <span class=\"token comment\">#将文件夹或文件移动到另一个文件路径下</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">mv</span> 文件夹1或文件名1 文件夹2或文件名2 <span class=\"token comment\">#将文件夹或文件名更名 </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-f 强制移动</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-u 只替换更新的文件夹</pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"网络\"><a class=\"anchor\" href=\"#网络\">#</a> 网络</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#centOS7 中网络配置文件在 cd/etc/sysconfig/network-scripts</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">ifconfig</span> <span class=\"token comment\">#查看网络配置</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">ping</span> <span class=\"token comment\">#ping 一个网址</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"主机\"><a class=\"anchor\" href=\"#主机\">#</a> 主机</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">hostname</span> <span class=\"token comment\">#查看主句名称</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">hostname</span> 名称 <span class=\"token comment\">#修改名称，重启后生效</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"修改环境变量\"><a class=\"anchor\" href=\"#修改环境变量\">#</a> 修改环境变量</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">vi</span> /etc/profile <span class=\"token comment\">#修改全局环境变量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>:w <span class=\"token comment\">#保存修改的环境变量</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>:q <span class=\"token comment\">#退出</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>:wq <span class=\"token comment\"># 保存环境变量并退出</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"硬链接和软链接\"><a class=\"anchor\" href=\"#硬链接和软链接\">#</a> 硬链接和软链接</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ln</span> 文件路径1 文件路径2 <span class=\"token comment\">#创建软链接 (符号链接)-- 删除源文件链接失效</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">ln</span> -s 文件路径1 文件路径2 <span class=\"token comment\">#创建硬链接 -- 删除源文件链接依然有效</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">touch</span> 文件名 <span class=\"token comment\">#创建文件</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"字符串\"</span> <span class=\"token operator\">>></span> 文件名 <span class=\"token comment\">#向文件写入字符串</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"vim编辑器简略\"><a class=\"anchor\" href=\"#vim编辑器简略\">#</a> vim 编辑器 (简略)</h2>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cyMDE1LzUxNTY4NC8yMDE1MDMvMjcxNzE1NTUwMDU2NzU2LmpwZw==\">https://images0.cnblogs.com/blog2015/515684/201503/271715550056756.jpg</span>&quot; alt=&quot;vim&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">vim</span> 文件名/路径下的文件 <span class=\"token comment\">#如果文件不存在新建文件并编辑，如果存在则直接编辑</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#按下 i 进入编辑模式</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#按下：进入底线命令模式，如果是在编辑模式下要先按 esc</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#编辑命令</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>数字<span class=\"token operator\">&lt;</span>space<span class=\"token operator\">></span> <span class=\"token comment\">#输入数字后按下空格光标移动 n 个位置</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>数字<span class=\"token operator\">&lt;</span>enter<span class=\"token operator\">></span> <span class=\"token comment\">#输入数字后按下回车光标移动 n 行</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">0</span>或者home键 <span class=\"token comment\">#回到文件开头</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>$或者end键 <span class=\"token comment\">#回到文件末尾</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>u <span class=\"token comment\">#复原前一个动作</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#底线命令</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>:w <span class=\"token comment\">#保存修改的文件变量</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>:q <span class=\"token comment\">#退出</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>:wq <span class=\"token comment\">#保存文件并退出</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>:wq<span class=\"token operator\">!</span> <span class=\"token comment\">#强制保存并退出</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>:set nu <span class=\"token comment\">#设置行号</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>:set nonu <span class=\"token comment\">#取消设置行号</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">#ctrl+z 退出 vim</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"账号管理\"><a class=\"anchor\" href=\"#账号管理\">#</a> 账号管理</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">useradd</span> -m 用户名 <span class=\"token comment\">#自动创建该用户的主目录</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>-c <span class=\"token string\">\"描述\"</span> <span class=\"token comment\">#指定一段描述</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-d <span class=\"token comment\">#指定用户主目录，如果主目录不存在需要使用 - m</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-g <span class=\"token comment\">#指定用户组</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-G <span class=\"token comment\">#指定用户的附加组</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>-m <span class=\"token comment\">#使用者目录不在则自动创建</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>-s Shell文件 <span class=\"token comment\">#指定用户登录的 shell</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>-u <span class=\"token comment\">#指定用户的用户号如果有 - o 选项可以重复使用其他用户的标识号</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">userdel</span> -r 用户名 <span class=\"token comment\">#删除用户及其目录</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>-r <span class=\"token comment\">#清空目录</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">usermod</span> 对应修改内容 用户名</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">usermod</span> -d /home/xu honshen <span class=\"token comment\">#将 honshen 用户的目录 honshen 修改为 xu</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">su</span> 用户名 <span class=\"token comment\">#切换用户，su - 用户名 切换到用户且到用户目录下</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>password 用户名 <span class=\"token comment\">#通过 root 创建账户后修改账户密码，Linux 输入密码是不会显示的</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>password <span class=\"token comment\">#修改自己账户的密码</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>password -l 用户名 <span class=\"token comment\">#锁定一个用户不能登录</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>password -u 用户名 <span class=\"token comment\">#解锁一个用户</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>password -d 用户名 <span class=\"token comment\">#清除密码，清除后不能登录</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"用户组\"><a class=\"anchor\" href=\"#用户组\">#</a> 用户组</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#用户组的增删改查是对 /etc/group 文件的更新</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">groupadd</span> 用户组名 <span class=\"token comment\">#添加一个用户组，id 从 1000 开始</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">groupadd</span> -d  <span class=\"token number\">1003</span> 用户组名 <span class=\"token comment\">#添加一个用户组，id 为 1003</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">groupdel</span> 用户组名 <span class=\"token comment\">#删除一个用户组</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">groupmod</span> -g id名 -n 新用户组名 用户组 <span class=\"token comment\">#给一个用户组更名更 id</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>$ newgrp root <span class=\"token comment\">#登录当前用户切换到 root 组</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"磁盘\"><a class=\"anchor\" href=\"#磁盘\">#</a> 磁盘</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">df</span> <span class=\"token comment\">#列出文件整体使用量 (以字节为单位)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">df</span> -h <span class=\"token comment\">#列出文件整体使用量 (以 M 为单位)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">du</span> <span class=\"token comment\">#检查磁盘空间使用量</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">du</span> -a <span class=\"token comment\">#检查磁盘及子文件夹</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">du</span> -sm  /* <span class=\"token comment\">#检查根目录下的文件占用的容量，一般 /usr 占用资源最大</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"外部设备\"><a class=\"anchor\" href=\"#外部设备\">#</a> 外部设备</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mount</span> /dev/xu /mnt/xu <span class=\"token comment\">#将名为 xu 的 u 盘挂载到 mnt 目录下，来实现访问 u 盘</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">umount</span> -f 挂载位置<span class=\"token comment\">#强制卸载 u 盘</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"进程\"><a class=\"anchor\" href=\"#进程\">#</a> 进程</h2>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ps</span> <span class=\"token comment\">#查看当前系统进程</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">ps</span> -help <span class=\"token comment\">#查看命令的帮助</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-a <span class=\"token comment\">#显示所有进程</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-u <span class=\"token comment\">#i</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-x <span class=\"token comment\">#显示后台进程的参数</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">grep</span> <span class=\"token comment\">#查找文件中符合条件的字符串</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># | 是管道符 A|B 将 A 的结果拿给 B</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">ps</span> -aux<span class=\"token operator\">|</span><span class=\"token function\">grep</span> nodejs <span class=\"token comment\">#查看所有 nodejs 进程</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">ps</span> -ef<span class=\"token operator\">|</span><span class=\"token function\">grep</span> mysql <span class=\"token comment\">#查看 mysql 的父进程</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>pstree -pu <span class=\"token comment\">#以目录结构查看进程</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">ps</span> -ef <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token environment constant\">$USER</span> <span class=\"token comment\">#查看用户进程</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">ps</span> -aux<span class=\"token operator\">|</span><span class=\"token function\">grep</span> 进程<span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print <span class=\"token variable\">$2</span>&#125;'</span> <span class=\"token comment\">#查看进程号，如:ps -aux|grep nodejs|awk '&#123;print $2&#125;'</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">kill</span> -9 <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">ps</span> -aux<span class=\"token operator\">|</span><span class=\"token function\">grep</span> 进程<span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print <span class=\"token variable\">$2</span>&#125;'</span><span class=\"token variable\">`</span></span> <span class=\"token comment\">#杀掉指定进程如: kill -9 `ps -aux|grep hexo|awk '&#123;print $2&#125;'`</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>-p -u <span class=\"token comment\">#-p 显示父 id -u 显示用户组</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">kill</span> -9 进程id <span class=\"token comment\">#强制结束进程</span></pre></td></tr></table></figure></li>\n<li>\n<h2 id=\"防火墙\"><a class=\"anchor\" href=\"#防火墙\">#</a> 防火墙</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#查看 firewall 服务状态 systemctl status firewalld</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#开启、重启、关闭、firewalld.service 服务</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">service</span> firewalld start<span class=\"token comment\">#开启</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">service</span> firewalld restart<span class=\"token comment\">#重启</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">service</span> firewalld stop<span class=\"token comment\">#关闭</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 查看防火墙规则</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>firewall-cmd --list-all<span class=\"token comment\">#查看全部信息 firewall-cmd --list-ports# 只看端口信息</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#开启端口</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>开端口命令:firewall-cmd --zone<span class=\"token operator\">=</span>public --add-port<span class=\"token operator\">=</span><span class=\"token number\">80</span>/tcp --permanent</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>重启防火墙:systemctl restart firewalld.service</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>命令含义:</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>--zone <span class=\"token comment\">#作用域</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>--add-port<span class=\"token operator\">=</span> <span class=\"token number\">80</span>/tcp <span class=\"token comment\">#添加端口，格式为：端口 / 通讯协议</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>--permanent<span class=\"token comment\">#永久生效，没有此参数重启后失效</span></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"nohup挂载后台进程\"><a class=\"anchor\" href=\"#nohup挂载后台进程\">#</a> nohup 挂载后台进程</h1>\n<ul>\n<li>\n<p>使用命令 <code>onhup command [args...] &amp;</code>  挂载后台进程，接着使用 exit 断开与服务器的连接，终端会忽略收到 HUP（hangup）信号从而不关闭其所有子进程～如下:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>onhup hexo s -p <span class=\"token number\">80</span> <span class=\"token operator\">&amp;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">exit</span></pre></td></tr></table></figure></li>\n<li>\n<p>我们可以使用 <code>jobs -l</code>  或 <code>ps -ef</code>  查看后台进程，例如我们查看 nojs 进程并输出其进程 Id</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ps</span> -aux<span class=\"token operator\">|</span><span class=\"token function\">grep</span> nodejs<span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print <span class=\"token variable\">$2</span>&#125;'</span></pre></td></tr></table></figure></li>\n<li>\n<p>拿到进程号以后，我们使用 <code>fg jubNumber</code>  将该进程调至前台，并可以直接终结该进程</p>\n<p>我们也可以使用 <code>Ctrl+z</code>  来将一个前台命令放到后台并暂停执行</p>\n<p>接着我们使用 <code>bg jobNumber</code>  来将一个后台暂停的命令继续</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@iz2zeg6qs3stnlr0awniwwz hongsheng-xu<span class=\"token punctuation\">]</span><span class=\"token comment\"># nohup hexo s -p 80 &amp;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token number\">3032</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@iz2zeg6qs3stnlr0awniwwz hongsheng-xu<span class=\"token punctuation\">]</span><span class=\"token comment\"># nohup: ignoring input and appending output to ‘nohup.out’</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@iz2zeg6qs3stnlr0awniwwz hongsheng-xu<span class=\"token punctuation\">]</span><span class=\"token comment\"># jobs</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>+  Running                 <span class=\"token function\">nohup</span> hexo s -p <span class=\"token number\">80</span> <span class=\"token operator\">&amp;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">[</span>root@iz2zeg6qs3stnlr0awniwwz hongsheng-xu<span class=\"token punctuation\">]</span><span class=\"token comment\"># fg 1</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">nohup</span> hexo s -p <span class=\"token number\">80</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>^Z</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>+  Stopped                 <span class=\"token function\">nohup</span> hexo s -p <span class=\"token number\">80</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">[</span>root@iz2zeg6qs3stnlr0awniwwz hongsheng-xu<span class=\"token punctuation\">]</span><span class=\"token comment\"># bg 1</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>+ <span class=\"token function\">nohup</span> hexo s -p <span class=\"token number\">80</span> <span class=\"token operator\">&amp;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">[</span>root@iz2zeg6qs3stnlr0awniwwz hongsheng-xu<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span></pre></td></tr></table></figure></li>\n<li>\n<p>如果后台进程挂载失败，使用 <code>lsof -i:端口号</code> 去查看端口的进程，使用 <code>nestat</code>  去查看其占用的端口</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>losf -i:80</pre></td></tr></table></figure><figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">netstat</span> -ap<span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token number\">80</span></pre></td></tr></table></figure></li>\n<li>\n<p>接着使用 <code>kill -9 进程号</code> 去终结该进程的运行</p>\n</li>\n</ul>\n",
            "tags": [
                "HEXO搭建个人博客",
                "linux",
                "服务器"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/01/31/Hexo/%E7%AC%AC2%E7%AB%A0-%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BE%8E%E5%8C%96Hexo%E4%B8%BB%E9%A2%98shkoa%E7%9A%84%E9%85%8D%E7%BD%AE/",
            "url": "https://honshen.xyz/2021/01/31/Hexo/%E7%AC%AC2%E7%AB%A0-%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BE%8E%E5%8C%96Hexo%E4%B8%BB%E9%A2%98shkoa%E7%9A%84%E9%85%8D%E7%BD%AE/",
            "title": "第2章-博客的美化Hexo主题shkoa的配置",
            "date_published": "2021-01-31T04:12:45.000Z",
            "content_html": "<h1 id=\"第2章-博客的美化Hexo主题shoka的配置\"><a href=\"#第2章-博客的美化Hexo主题shoka的配置\" class=\"headerlink\" title=\"第2章-博客的美化Hexo主题shoka的配置\"></a>第2章-博客的美化Hexo主题shoka的配置</h1><p><strong>引言: 我们已经初始化个人博客并将代码发布至github,如果不懂可以查阅: <a href=\"/2020/12/13/Hexo/%E7%AC%AC1%E7%AB%A0-%E9%9B%B6%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BHEXO%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96/\">第1章-零基础使用HEXO搭建个人博客之HEXO及其初始化</a>,接下来我们需要对个人博客进行美化~</strong></p>\n<h1 id=\"下载依赖\"><a href=\"#下载依赖\" class=\"headerlink\" title=\"下载依赖\"></a>下载依赖</h1><blockquote>\n<p> <strong>首先我们进入自己博客所在的文件夹里,在此处打开Git bash,然后使用npm下载依赖</strong></p>\n<p> <img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_11-35-31.png\" alt=\"打开gitbash\"></p>\n<pre><code class=\"bash\"> npm i hexo-renderer-multi-markdown-it --save\n npm i hexo-autoprefixer --save\n npm i  hexo-algolia --save\n npm i hexo-algoliasearch --save\n npm i hexo-symbols-count-time --save\n npm i hexo-feed --save</code></pre>\n<p> 接着,我们在bash里去下载shoka这一款主题,由于代码存放于github所以下载主题的时间可能会很长,请耐心等待喔…</p>\n<pre><code class=\"bash\">git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka</code></pre>\n<p> 下载成功后,我们可以看到多了一个shoka的文件夹</p>\n<p> <img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_12-27-22.png\" alt=\"文件\"></p>\n</blockquote>\n<h1 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h1><blockquote>\n<p>这里推荐几篇shoka作者的博客</p>\n<ul>\n<li>基本配置: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUvY29tcHV0ZXItc2NpZW5jZS9ub3RlL3RoZW1lLXNob2thLWRvYy9jb25maWcv\">https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/</span></li>\n<li>页面配置: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUvY29tcHV0ZXItc2NpZW5jZS9ub3RlL3RoZW1lLXNob2thLWRvYy9kaXNwbGF5Lw==\">https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/</span></li>\n<li>依赖插件: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUvY29tcHV0ZXItc2NpZW5jZS9ub3RlL3RoZW1lLXNob2thLWRvYy9kZXBlbmRlbnRzLw==\">https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/</span></li>\n</ul>\n<p>我们打开shoka文件夹,找到里面_config.yml文件,这个文件是主题配置文件,使用vscode打开编辑配置如图,vscode下载地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v\">https://code.visualstudio.com/</span></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_13-46-23.png\" alt=\"主题配置文件\"></p>\n</blockquote>\n<blockquote>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_14-27-20.png\" alt=\"配置2\"></p>\n</blockquote>\n<blockquote>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_14-48-59.png\" alt=\"配置3\"></p>\n</blockquote>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly92YWxpbmUuanMub3JnL3F1aWNrc3RhcnQuaHRtbA==\">点击此处了解如何获取AppID和Appkey</span><br><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_15-06-43.png\" alt=\"配置4\"></p>\n</blockquote>\n<blockquote>\n<p>接下来我们修改全局配置文件_config.yml<strong>注意这个文件名和主题的文件名是一样的别修改错文件了</strong><br><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_15-27-23.png\" alt=\"全局配置1\"></p>\n</blockquote>\n<blockquote>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_15-39-09.png\" alt=\"全局配置2\"></p>\n</blockquote>\n<blockquote>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_15-41-43.png\" alt=\"全局配置3\"></p>\n</blockquote>\n<blockquote>\n<p>这些代码直接复制粘贴到全局配置文件即可这里会使用到搜索功能因此需要appId和apikey,这里有一篇博客能够帮助大家获取到appId和apikey: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDc5NDY4L2FydGljbGUvZGV0YWlscy8xMDczMzU2NjM=\">为Hexo增加algolia搜索功能</span></p>\n<pre><code class=\"yml\"># edit for Theme.shoka\nautoprefixer:\n  exclude:\n    - &#39;*.min.css&#39;\n\nmarkdown:\n  render: # 渲染器设置\n    html: false # 过滤 HTML 标签\n    xhtmlOut: true # 使用 &#39;/&#39; 来闭合单标签 （比如 &lt;br /&gt;）。\n    breaks: true # 转换段落里的 &#39;\\n&#39; 到 &lt;br&gt;。\n    linkify: true # 将类似 URL 的文本自动转换为链接。\n    typographer:\n    quotes: &#39;“”‘’&#39;\n  plugins: # markdown-it插件设置\n    - plugin:\n        name: markdown-it-toc-and-anchor\n        enable: true\n        options: # 文章目录以及锚点应用的class名称，shoka主题必须设置成这样\n          tocClassName: &#39;toc&#39;\n          anchorClassName: &#39;anchor&#39;\n    - plugin:\n        name: markdown-it-multimd-table\n        enable: true\n        options:\n          multiline: true\n          rowspan: true\n          headerless: true\n    - plugin:\n        name: ./markdown-it-furigana\n        enable: true\n        options:\n          fallbackParens: &quot;()&quot;\n    - plugin:\n        name: ./markdown-it-spoiler\n        enable: true\n        options:\n          title: &quot;你知道得太多了&quot;\n\nminify:\n  html:\n    enable: true\n    stamp: false\n    exclude:\n      - &#39;**/json.ejs&#39;\n      - &#39;**/atom.ejs&#39;\n      - &#39;**/rss.ejs&#39;\n  css:\n    enable: true\n    stamp: false\n    exclude:\n      - &#39;**/*.min.css&#39;\n  js:\n    enable: true\n    stamp: false\n    mangle:\n      toplevel: true\n    output:\n    compress:\n    exclude:\n      - &#39;**/*.min.js&#39;\n\nalgolia:\n  appId: #这里填上你的appId\n  apiKey: #这里填上你的apiKey\n  adminApiKey:  #这里填上你的adminApiKey\n  chunkSize: 5000\n  indexName: #填入自己的index name\n  fields:\n    - title: #必须配置\n    - path:  #必须配置\n    - categories: #推荐配置\n    - content:\n        strip: truncate,0,4000\n    - gallery:\n    - photos:\n    - tags:\n\nfeed:\n    limit: 20\n    order_by: &quot;-date&quot;\n    tag_dir: false\n    category_dir: false\n    rss:\n        enable: true\n        template: &quot;themes/shoka/layout/_alternate/rss.ejs&quot;\n        output: &quot;rss.xml&quot;\n    atom:\n        enable: true\n        template: &quot;themes/shoka/layout/_alternate/atom.ejs&quot;\n        output: &quot;atom.xml&quot;\n    jsonFeed:\n        enable: true\n        template: &quot;themes/shoka/layout/_alternate/json.ejs&quot;\n        output: &quot;feed.json&quot;</code></pre>\n<p><strong>另外需要注意的是你的每一篇博客都需要开头加入下述代码,这样表面这是一篇博客:</strong></p>\n<pre><code class=\"Markdown\">---\ntitle: 文章的标题\ndate: 文章发布是年/月/日 时/分/秒\ncategories:\n- [博客的分类]\ntags:\n---\n# 这里开始使用Markdown书写博客正文</code></pre>\n<p>举个栗子:</p>\n<pre><code class=\"Markdown\">---\ntitle: Markdown使用指南\ndate: 2020/12/24 12:10:45\ncategories:\n- [Markdown使用指南]\ntags:\n---\n# MarkdownNote\n\ncommon grammar--MarkdownNote\n\n推荐markdown软件[Typora](https://www.typora.io/)\n后文略...</code></pre>\n<p><strong>tips:这里只列出了大致需要修改的地方,其他地方你可以阅读主题作者的博客获得更多配置信息</strong> </p>\n</blockquote>\n<h1 id=\"修改图片\"><a href=\"#修改图片\" class=\"headerlink\" title=\"修改图片\"></a>修改图片</h1><blockquote>\n<p>进入到shoka文件夹里的source文件夹,再进入images文件夹在这里你可以更改为自己喜欢的图片,<strong>注意图片要和原来的文件名字一模一样否则会加载出错</strong></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_15-19-09.png\" alt=\"修改图片\"></p>\n</blockquote>\n",
            "tags": [
                "HEXO搭建个人博客",
                "Hexo",
                "博客",
                "主题"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/01/30/CCode/CProgrammaCode%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/",
            "url": "https://honshen.xyz/2021/01/30/CCode/CProgrammaCode%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/",
            "title": "CProgrammaCode算法集合",
            "date_published": "2021-01-30T04:20:45.000Z",
            "content_html": "<h1 id=\"cprogrammacode算法集合\"><a class=\"anchor\" href=\"#cprogrammacode算法集合\">#</a> CProgrammaCode 算法集合</h1>\n<p><strong>C/C++</strong></p>\n<h2 id=\"最短路径算法详见short_path_link_gpcpp\"><a class=\"anchor\" href=\"#最短路径算法详见short_path_link_gpcpp\">#</a> 最短路径算法 (详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hvbmdzaGVuZy14dS9DUHJvZ3JhbW1hQ29kZS9ibG9iL21haW4vc2hvcnRfcGF0aF9saW5rX0dQLmNwcA==\"> short_path_link_GP.cpp</span>)</h2>\n<blockquote>\n<p>图邻接表 (GP)</p>\n</blockquote>\n<blockquote>\n<p>纵向优先搜索遍历 (DFS)</p>\n</blockquote>\n<h2 id=\"分块查找算法详见blocking_searchcpp\"><a class=\"anchor\" href=\"#分块查找算法详见blocking_searchcpp\">#</a> 分块查找算法 (详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hvbmdzaGVuZy14dS9DUHJvZ3JhbW1hQ29kZS9ibG9iL21haW4vYmxvY2tpbmdfc2VhcmNoLmNwcA==\"> blocking_search.cpp</span>)</h2>\n<blockquote>\n<p>按位段分块</p>\n</blockquote>\n<blockquote>\n<p>映射查找</p>\n</blockquote>\n<h2 id=\"排序算法详见array_sort\"><a class=\"anchor\" href=\"#排序算法详见array_sort\">#</a> 排序算法 (详见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hvbmdzaGVuZy14dS9DUHJvZ3JhbW1hQ29kZS9ibG9iL21haW4vYXJyYXlfc29ydC5jcHA=\"> array_sort</span>)</h2>\n<blockquote>\n<p>直接插入排序</p>\n</blockquote>\n<blockquote>\n<p>选择排序</p>\n</blockquote>\n<blockquote>\n<p>冒泡排序</p>\n</blockquote>\n<blockquote>\n<p>快速排序</p>\n</blockquote>\n",
            "tags": [
                "C&C++算法设计",
                "算法",
                "c",
                "c++"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/01/28/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E5%9B%9B%E7%AB%A0%E9%9D%A2%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(Java%E6%A0%B8%E5%BF%83)/",
            "url": "https://honshen.xyz/2021/01/28/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E5%9B%9B%E7%AB%A0%E9%9D%A2%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(Java%E6%A0%B8%E5%BF%83)/",
            "title": "第4章-面对象编程(Java核心)",
            "date_published": "2021-01-28T03:28:45.000Z",
            "content_html": "<h1 id=\"Java笔记–第4章面对象编程-Java核心\"><a href=\"#Java笔记–第4章面对象编程-Java核心\" class=\"headerlink\" title=\"Java笔记–第4章面对象编程(Java核心)\"></a>Java笔记–第4章面对象编程(Java核心)</h1><h1 id=\"面向过程-amp-面向对象-OOP\"><a href=\"#面向过程-amp-面向对象-OOP\" class=\"headerlink\" title=\"面向过程&amp;面向对象(OOP)\"></a>面向过程&amp;面向对象(OOP)</h1><ul>\n<li>面向过程思想<ul>\n<li>步骤简单,第一步做什么,第二步做什么……</li>\n<li>面对过程适合处理一些较为简单的问题</li>\n</ul>\n</li>\n<li>面向对象思想<ul>\n<li>物理类聚,分类的思维模式,首先解决问题需要哪些分类,然后对这些分类进行单独思考,最后对分类下的细节进行面向过程的思索</li>\n<li>面向对象审核处理复杂问题,审核处理多人协作</li>\n</ul>\n</li>\n<li>面向对象编程的本质: 以类的方式组织代码,以对象的组织(封装)数据</li>\n<li>三大特性: 封装、继承、多态</li>\n<li>类和对象的关系<ul>\n<li>类是一种抽象的数据类型,它是对某一类事物整体描述/定义,但不能代表某一个具体的事物</li>\n<li>对象是抽象概念的具体实例</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"方法详解\"><a href=\"#方法详解\" class=\"headerlink\" title=\"方法详解\"></a>方法详解</h1><blockquote>\n<ul>\n<li><p>静态方法和非静态方法</p>\n<ul>\n<li>静态方法的修饰符static,非静态方法不加static</li>\n</ul>\n<pre><code class=\"java\">//静态方法\n//demo1\npublic class Demo1&#123;\n    //可以直接调用add()\n    //其他类调用Demo1.add();\n    public static int add()&#123;\n        //执行语句\n    &#125;\n&#125;\n//demo2\npublic class Demo2&#123;\n    Demo1.add();\n&#125;\n//非静态方法\n//demo1\npublic class Demo1&#123;\n    //方法里除static修饰的方法都可以直接调用add()\n    public int add()&#123;\n       //执行语句\n    &#125;\n&#125;\n//demo2\npublic class Demo2&#123;\n    //首先实例化对象\n    //对象类型 对象名 = 对象值\n    Demo1 demo1 = new Demo1();\n    demo1.add();\n&#125;</code></pre>\n<pre><code class=\"java\">public class Demo&#123;\n    /*\n    a,b方法中可以互相调用对方\n    public void a()&#123;&#125;\n    public void b()&#123;&#125;\n    */\n    /*\n    a不能直接调用b,但是b可以调用a\n    原因: static是和类一起加载,不加static则是实例化后方法才存在\n    public static void a()&#123;&#125;\n    public void b()&#123;&#125;\n    */\n    //可以互相调用\n    public static void a()&#123;\n        //也可以Demo.b()\n        b();\n    &#125;\n    public static void b()&#123;\n        //也可以Demo.a()\n        a();\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p>this关键字</p>\n<ul>\n<li>this()调用自己的构造器</li>\n<li>总是指向对象本身</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"创建与初始化对象\"><a href=\"#创建与初始化对象\" class=\"headerlink\" title=\"创建与初始化对象\"></a>创建与初始化对象</h1><blockquote>\n<ul>\n<li><p>使用new关键字创建对象,会分配内存空间,对对象进行默认的初始化</p>\n</li>\n<li><p>类的构造器也称为构造方法是在进行创建对象的时候必须调用的</p>\n<ul>\n<li><p>必须和类的名字相同</p>\n</li>\n<li><p>必须没有返回值且不能写void</p>\n<pre><code class=\"java\">public class Student&#123;\n    //属性: 字段\n    String name;\n    int age;\n    //方法\n    public void study&#123;\n        //this代表当前类\n        System.out.println(this.name);\n    &#125;\n&#125;\n//================\npackage xyz.honshen;\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        //类的实例化: stu1和stu2为两个不同实例\n        Student stu1 = new Student(); //对对象默认初始化\n        Student stu2 = new Student();\n        stu1.sayName(); //null\n        stu1.changeName(&quot;abc&quot;);\n        stu1.sayName(); //abc\n        stu2.sayName(); //null\n    &#125;\n&#125;</code></pre>\n<pre><code class=\"java\">//构造器\n定义一个Student类\npublic class Student &#123;\n    /*\n    public Student()&#123;&#125;\n    */\n&#125;\n//====================\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        //Student类中默认包含一个构造方法\n        Student stu = new Student();\n    &#125;\n&#125;\n//=====================\npublic class Student &#123;\n    String name;\n    //无参构造\n    public Student()&#123;\n        //实例化会调用构造方法,一般用来初始化值\n        //使用new关键字本质调用构造器\n        this.name = &quot;abcd&quot;;\n    &#125;\n    /*\n    Alt+insert快捷生成构造器\n    一旦定义有参构造,无参构造必须显示定义\n    public Student()&#123;&#125;\n    public Student(String name)&#123;\n    //执行代码\n    &#125;\n    */\n&#125;</code></pre>\n</li>\n<li><p>内存分析</p>\n<ul>\n<li><p>new出的对象实例存在堆中,变量名存在栈里是引用类型</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-27_16-34-45.png\" alt=\"内存分析\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"三大特性\"><a href=\"#三大特性\" class=\"headerlink\" title=\"三大特性\"></a>三大特性</h1><blockquote>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><ul>\n<li><p>通常应禁止直接访问一个对象中主句的实际表示,而应通过操作接口来访问,这称为信息隐藏,隐藏代码的实现细节</p>\n</li>\n<li><p>属性私有 get/set</p>\n</li>\n<li><p>高内聚,低耦合:类的内部数据操作自己完成不允许外部干涉,仅暴露少量方法给外部</p>\n<pre><code class=\"java\">public class Student &#123;\n    //不能通过实例操作name\n    private String name;\n    //可以通过实例.age操作age\n    int age; //相当于public int age;\n    //提供方法去操作数据,而不是直接用.去访问\n    public void setName(String name)&#123;\n        this.name = name;\n    &#125;\n    public String getName()&#123;\n        return this.name;\n    &#125;\n&#125;\n//idea中使用快捷键Alt+insert可以直接添加get和set方法继承</code></pre>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><ul>\n<li><p>类和类之间的一种关系,对一批类的抽象</p>\n</li>\n<li><p>父类和子类,子类是父类的扩展,也叫派生类,用extends来表示</p>\n</li>\n<li><p>子类可以继承父类的public方法和public属性,final不能继承</p>\n<pre><code class=\"java\">//java中所有的类都默认直接或间接继承于object\n//java只有单继承没有多继承\n//父类,继承于object类\npublic class Person &#123;\n    public void say()&#123;\n        System.out.println(&quot;nice!&quot;);\n    &#125;\n    private void set()&#123;\n        System.out.println(&quot;cant use&quot;);\n    &#125;\n&#125;\n//子类\npublic class Student extends Person&#123;\n    //extends先执行父类构造器,在执行子类构造器\n    /*\n    public Student()&#123;\n    //调用父类的构造器必须要在第一行\n        super();//super(参数)调用有参构造,不写默认调用\n        //子类的其他语句\n    &#125;\n    */\n&#125;\n//Application\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        Student stu = new Student();\n        //只能使用public的方法,private方法不能使用\n        stu.say();\n    &#125;\n&#125;</code></pre>\n<ul>\n<li>super关键字<ul>\n<li>super调用父类构造方法必须在构造方法第一个</li>\n<li>super必须只能出现在子类方法或构造方法中</li>\n<li>super和this不能同时调用构造方法</li>\n<li>this本身调用者,super父类对象的引用</li>\n<li>this没有继承也能使用,super在继承下使用</li>\n<li>this()本类方法的构造,super()父类关键字的构造</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"java\">//父类\npublic class Person &#123;\n    protected String name;\n    public void say()&#123;\n        System.out.println(&quot;nice!&quot;);\n    &#125;\n&#125;\n//子类\npublic class Student extends Person&#123;\n    public void sayName()&#123;\n        //关键字super,调用父类的属性但不能调用私有属性和方法\n        System.out.println(super.name);\n        this.say();//子类的say();\n        super.say();//父类的say();\n    &#125;\n    public void say()&#123;&#125;\n&#125;</code></pre>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><ul>\n<li><p>多态存在的条件:有继承关系,子类重写父类方法,父类引用指向子类</p>\n</li>\n<li><p>classCastException–父类子类转换异常</p>\n<pre><code class=\"java\">//对象能执行那些方法看左边!\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        Son son=new Son();\n        //子类能够调用的方法来自父类和子类本身\n        son.test1(); //Son.test1()\n        //父类的引用指向子类,向上转型,调用方法来自本身,但不能调用子类方法\n        Father father=new Son();\n        father.test1(); //Father.test1()\n        //高转低,强制转换调用子类的放阿飞\n        ((Son)father).test2(); //Son.test2()\n    &#125;\n&#125;\n//父类\npublic class Father &#123;\n    public void test1()&#123;\n        System.out.println(&quot;Father.test()1&quot;);\n    &#125;\n&#125;\n//子类\npublic class Son extends Father&#123;\n    public  void test1()&#123;\n        System.out.println(&quot;Son.test1&quot;);\n    &#125;\n    public void test2()&#123;\n        System.out.println(&quot;Son.test2&quot;);\n    &#125;\n&#125;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"方法的重写\"><a href=\"#方法的重写\" class=\"headerlink\" title=\"方法的重写\"></a>方法的重写</h1><blockquote>\n<ul>\n<li>需要有继承关系,方法名必须相同,参数列表需要相同</li>\n<li>重写的修饰符范围可以扩大但是不能缩小</li>\n<li>重写抛出的异常范围可以缩小但是不能扩大</li>\n<li>不能重写的方法<ul>\n<li>static静态</li>\n<li>final常量池,final类不能继承</li>\n<li>private私有</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"java\">//主程序\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        Son son=new Son();\n        son.test(); //Son.test()\n        //父类的引用指向子类,向上转型\n        Father father=new Son();\n        father.test(); //Father.test()\n    &#125;\n&#125;\n//父类\npublic class Father &#123;\n    public void test()&#123;\n        System.out.println(&quot;Father.test()&quot;);\n    &#125;\n&#125;\n//子类\npublic class Son extends Father&#123;\n    //Father father=new Son();\n    //非静态的方法才可以被重写,子类重写了父类的方法\n    @Override //override重新这是注解\n    public void test() &#123;\n        super.test();\n    &#125;\n    /*\n    这是原本子类的方法被重写后变成了上面的方法\n    public  void test()&#123;\n        System.out.println(&quot;Son.test()&quot;);\n    &#125;\n    * */\n&#125;</code></pre>\n</blockquote>\n<h1 id=\"instanceof关键字\"><a href=\"#instanceof关键字\" class=\"headerlink\" title=\"instanceof关键字\"></a>instanceof关键字</h1><blockquote>\n<ul>\n<li><p>判断两个类之间是否有关系</p>\n<pre><code class=\"java\">//Object &gt; Person &gt; Student\n//Object &gt; String\nObject object = new Student();\nif (object instanceof Student)&#123; //true\n    //执行语句\n&#125;\n//通过判断是否有关系就可以强制转换\nobject instanceof Student;//true\nobject instanceof Object; //true\nobject instanceof Person; //true\nobject instanceof String; //false\n//父类的引用指向子类的对象\nPerson person = new Student();\nperson instanceof Student;//true\nperson instanceof Object; //true\nperson instanceof Person; //true\nperson instanceof String; //编译报错\n\n//转换低(子类)-&gt;高(父类)自动\n//转换高(父类)-&gt;低(子类)强制\nFather father=new Son();//被自动强制转换为了父类\n((Son)father).test2();//强制转换为子类调用子类的方法\n//子类转父类,向上转型\n//父类转子类,向下转型,强制转换,可能丢失方法</code></pre>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h1><blockquote>\n<pre><code class=\"java\">public class Father &#123;\n    static &#123;\n        //静态代码块,用于初始化\n        //和类一起加载并执行一次,且只执行一次\n    &#125;\n    &#123;\n        //匿名代码块,用于赋初始值,在每次生成实例对象时都会调用\n    &#125;\n    //加了static的属性称为类变量,或静态变量\n    //静态变量是所有实例共享的变量\n    private static int age;\n    //非静态变量\n    private double height;\n\n    public void test()&#123;\n        Father.age;//类变量可以直接调用\n        Father father = new Father();\n        //非静态变量需要实例化才能使用属性\n        father.height;\n        father.age;\n    &#125;\n&#125;\n//静态导入包\nimport static java.lang.Math.random;\nimport static java.lang.PI;   \nrandom();//可以之间调用Math.random();\nPI;//Math.PI;</code></pre>\n</blockquote>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><blockquote>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_11-03-00.png\" alt=\"抽象类\"></p>\n<pre><code class=\"java\">//abstract 抽象类,不能被实例化\npublic abstract class Father &#123;\n    //修饰方法: 抽象方法只有方法名字,没有方法实现\n    //继承抽象类的子类必须重写抽象类的所有方法\n    //如果子类也是抽象类,则子子类去重写所有方法\n    public abstract void say();\n    //一旦方法使用abstract,该类必须是抽象类\n&#125;\n//子类\npublic class Son extends Father&#123;\n    @Override\n    //必须重写父类的方法\n    public void say() &#123;\n\n    &#125;\n&#125;\n//子类,除非子类也是抽象类\npublic abstract class Son extends Father&#123;\n&#125;\n</code></pre>\n</blockquote>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><blockquote>\n<ul>\n<li><p>普通类: 只有具体实现</p>\n</li>\n<li><p>抽象类: 具体实现和规范(抽象方法)都有</p>\n</li>\n<li><p>接口: 只有规范</p>\n<pre><code class=\"java\">//接口1\npublic interface UserServer &#123;\n    //接口中不能写方法的实现,方法都是public abstract\n    void run(String name);\n    //private void test();//报错\n    //接口中定义均为public static final\n    int age=10; //public static final int age=10\n&#125;\n//接口2\npublic interface TimeServer &#123;\n    void time();\n&#125;\n\n//类可以实现接口,重写接口中的所有方法\n//接口可以多继承\n//实现: 与接口同名+Impl\npublic class UserSeverImpl implements UserServer,TimeServer&#123;\n\n    @Override\n    public void run(String name) &#123;\n\n    &#125;\n\n    @Override\n    public void time() &#123;\n\n    &#125;\n&#125;</code></pre>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><blockquote>\n<h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2><ul>\n<li><p>在A类中定义一个内部类,B对A来说就是内部类</p>\n<pre><code class=\"java\">//外部类\npublic class Outer &#123;\n    private int id;\n    public void out()&#123;\n        System.out.println(&quot;Outer&quot;);\n    &#125;\n    //内部类\n    public class Inner&#123;\n        public void in()&#123;\n            System.out.println(&quot;In&quot;);\n        &#125;\n        //内部类可以访问外部内的私有属性\n        public int getId()&#123;\n            return id;\n        &#125;\n    &#125;\n&#125;\n//Application\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n       Outer outer = new Outer();\n       //通过外部类来实例化内部类\n        Outer.Inner inner = outer.new Inner();\n        inner.in();//In\n        System.out.println(inner.getId());//0\n    &#125;\n&#125;</code></pre>\n<h2 id=\"静态类\"><a href=\"#静态类\" class=\"headerlink\" title=\"静态类\"></a>静态类</h2><ul>\n<li><p>通过static修饰的内部类</p>\n<pre><code class=\"java\">//外部类\npublic class Outer &#123;\n    private int id;\n    public void out()&#123;\n        System.out.println(&quot;Outer&quot;);\n    &#125;\n    //静态类\n    public static class Inner&#123;\n        public void in()&#123;\n            System.out.println(&quot;In&quot;);\n        &#125;\n        //内部类可以访问外部内的私有属性\n        public int getId()&#123;\n            //return id;此时不能访问id\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><pre><code class=\"java\">//外部类\npublic class Outer &#123;\n    private int id;\n    //局部内部类\n    public void in()&#123;\n        class Inner&#123;\n            public int i;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><pre><code class=\"java\">public class Main&#123;\n    public static void main(String[] args) &#123;\n        //匿名内部类,不赋值,也可以直接调用方法\n        //不用将实例保存于变量\n       new Apple().eat();\n    &#125;\n&#125;\nclass Apple&#123;\n    public void eat()&#123;&#125;\n&#125;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"异常机制\"><a href=\"#异常机制\" class=\"headerlink\" title=\"异常机制\"></a>异常机制</h1><blockquote>\n<p>java把异常当做对象处理,定义了一个基类java.lang.Throwable作为所有类的超类</p>\n<p>异常类分为:错误(ERROR)和异常(Exception)</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_13-26-25.png\" alt=\"异常机制\"></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_13-31-43.png\" alt=\"错误\"></p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_13-31-56.png\" alt=\"异常\"></p>\n<h2 id=\"异常处理常用五个关键字-try-catch-finally-throw-thorws\"><a href=\"#异常处理常用五个关键字-try-catch-finally-throw-thorws\" class=\"headerlink\" title=\"异常处理常用五个关键字(try,catch,finally,throw,thorws)\"></a>异常处理常用五个关键字(try,catch,finally,throw,thorws)</h2><ul>\n<li>异常类型,catch参数</li>\n</ul>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_13-42-57.png\" alt=\"异常类型\"></p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n       int a=10;\n       int b=0;\n       try&#123;//监控异常\n           System.out.println(a/b);\n       &#125;catch(ArithmeticException e)&#123;\n           //catch中的参数是想要捕获的异常类型\n           //最高类型Throwable\n           //捕获异常\n           System.out.println(e);//java.lang.ArithmeticException: / by zero\n        &#125;finally &#123;\n           //程序无论是否出现异常都会执行的代码块\n       &#125;\n&#125;\n//java支持依次捕获异常\ntry&#123;\n    2/0;//Exception异常\n&#125;catch(Error e)&#123;\n&#125;catch(Exception e)&#123;\n    //此处将捕获到2/0异常\n&#125;catch(Throwable e)&#123;\n    //按照异常类型从小到大写\n&#125;\n//主动抛出异常\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n       int a=10;\n       int b=0;\n       Application.divide1(a,b);\n       Application.divide2(a,b);\n    &#125;\n    public static int divide1(int a,int b)&#123;\n        if (b==0)&#123;\n            //一般在方法中主动抛出异常\n            throw new ArithmeticException();\n        &#125;\n        return a/b;\n    &#125;\n    //使用throws在方法上抛出异常\n    public  static int divide2 (int a, int b) throws ArithmeticException&#123;\n        return a/b;\n    &#125;\n&#125;\n//idea快捷键,选中要生成try-catch的代码块\n//Ctrl + Alt + T \n</code></pre>\n</blockquote>\n<h1 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-28_14-07-25.png\" alt=\"自定义异常\"></p>\n<pre><code class=\"java\">//自定义异常\npublic class MyException extends Exception&#123;\n    private int index;\n    public MyException(int index) &#123;\n        this.index = index;\n    &#125;\n    //打印异常信息\n    public String toString()&#123;\n        return &quot;MyException &#123;&quot; +\n                &quot;ArrayIndexOutOfBounds: &quot;+index+\n                &quot;&#125;&quot;;\n    &#125;\n&#125;\n//抛出异常\npublic class Application &#123;\n    public static void main(String[] args) throws MyException &#123;\n        int index = 11;\n        if(index&gt;10)&#123;\n            throw new MyException(index);//Exception in thread &quot;main&quot; MyException &#123;ArrayIndexOutOfBounds: 11&#125;\n        &#125;\n    &#125;\n&#125;\n//出现异常安装alt + enter键出现提示选项修复\n//尽量添加Finally语句释放占用的资源</code></pre>\n",
            "tags": [
                "Java笔记",
                "java",
                "笔记",
                "算法"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/01/27/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E7%BB%84/",
            "url": "https://honshen.xyz/2021/01/27/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%95%B0%E7%BB%84/",
            "title": "第3章-方法详解及数组",
            "date_published": "2021-01-27T03:28:45.000Z",
            "content_html": "<h1 id=\"Java笔记–第3章方法详解及数组\"><a href=\"#Java笔记–第3章方法详解及数组\" class=\"headerlink\" title=\"Java笔记–第3章方法详解及数组\"></a>Java笔记–第3章方法详解及数组</h1><h1 id=\"方法的定义\"><a href=\"#方法的定义\" class=\"headerlink\" title=\"方法的定义\"></a>方法的定义</h1><ul>\n<li><p>java方法是语句的集合,它们在一起执行一个功能</p>\n</li>\n<li><p>方法是解决一类问题的步骤的有序组合</p>\n</li>\n<li><p>方法包含于类或对象中</p>\n</li>\n<li><p>方法在程序中被创建,在其他地方被引用</p>\n</li>\n<li><p>方法的原子性: 一个方法只完成一个工能,这样利于后期的扩展</p>\n<pre><code class=\"java\">//System.out.println();其中System为系统类,out为输出对象,println为方法\n//方法的命名规则:首字母小写,驼峰命名\n//main方法\npublic static void main(String[] args) &#123;\n&#125;\n//static将变量提升为类变量,可以直接在该类的其他地方调用</code></pre>\n</li>\n<li><p>方法包含一个方法头和一个方法体</p>\n<ul>\n<li>修饰符: 可选,告诉编译器如何调用该方法,定义了方法的访问类型</li>\n<li>返回值类型: 方法可能有返回值–returnValueType是返回值类型;方法没有返回值,则returnValueType为void</li>\n<li>方法名: 方法名和参数表共同构成方法签名</li>\n<li>参数类型: 方法被调用时传递值给参数,这个值称为实参或者变量,参数列表是指参数类型、顺序和参数个数,参数是可选的可以不包含任何参数</li>\n<li>方法体: 方法包含的具体语句,定义该方法的功能</li>\n</ul>\n<pre><code class=\"java\">修饰符有: public protected default private\n修饰符 返回值 方法名 (参数类型 参数名)&#123;\n    //方法体\n&#125;\nadd(1,2);//1,2是实际参数\npublic static int add(int a, int b)&#123;\n    //a,b为形式参数\n    return a+b;//return终止方法的进行,遇到return直接返回\n&#125;</code></pre>\n</li>\n<li><p>值传递和引用传递</p>\n<ul>\n<li>java基本类型都是值传递</li>\n<li>java引用类型:类,接口类型,数组为引用传递</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"方法的重载\"><a href=\"#方法的重载\" class=\"headerlink\" title=\"方法的重载\"></a>方法的重载</h1><blockquote>\n<p>在一个类中,有相同的函数名称,但形参不同的函数</p>\n<p>重载的规则:</p>\n<ul>\n<li>方法名称相同</li>\n<li>参数列表必须不同(个数、参数排列顺序或类型不同)</li>\n<li>返回类型不同不能做为方法重载,重载的方法返回类型可以相同或不同</li>\n<li>方法名称相同时,编译器会根据参数的个数、参数的类型匹配对应的方法，匹配失败编译器报错</li>\n</ul>\n<pre><code class=\"java\">double m=max(1,2); //会调用第二个方法返回2.0\nint m=max(1,2);//会调用第一个方法返回2,但是注意返回值不同并不能构成方法的重载\npublic static int max(int a, int b)&#123;\n    return a&gt;b?a:b;\n&#125;\npublic static double max(double a, double b)&#123;\n    return a&gt;b?a:b;\n&#125;</code></pre>\n</blockquote>\n<h1 id=\"命令行传参\"><a href=\"#命令行传参\" class=\"headerlink\" title=\"命令行传参\"></a>命令行传参</h1><ul>\n<li><p>新建一个java文件如下</p>\n<pre><code class=\"java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        for (String val: args)\n            System.out.println(val);\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p>在该文件路径下打开cmd,使用javac Demo.java编译</p>\n</li>\n<li><p>回退到包的src路径下使用 java 包名.Demo才能运行如: java xyz.honshen.Demo</p>\n</li>\n<li><p>在命令后加入参数 结果如下</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-26_17-28-06.png\" alt=\"命令行参数\"></p>\n</li>\n<li><p>在main函数中将命令行参数输出到了控制台</p>\n</li>\n</ul>\n<h1 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-26_17-58-29.png\" alt=\"可变参数\"></p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n   System.out.println(sum(1,2,3,4)); //10\n   System.out.println(sum(1,2,3,4,5)); //15\n   &#125;\n//可变参数\npublic static int sum (int... num)&#123;\n       int sum = 0;\n       for(int val : num)\n           sum+=val;\n       return sum;\n   &#125;</code></pre>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><ul>\n<li>递归结构包括两个部分:<ul>\n<li>递归头:什么时候不调用自身方法。如果没有头，将陷入死循环。递归体:什么时候需要调用自身方法。</li>\n<li>递归体: 什么时候需要调用自身方法</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><blockquote>\n<ul>\n<li><h2 id=\"数组的创建\"><a href=\"#数组的创建\" class=\"headerlink\" title=\"数组的创建\"></a>数组的创建</h2><ul>\n<li>数组是相同类型的数据集合</li>\n<li>下标从0到arr.length-1,索引从0开始</li>\n</ul>\n<pre><code class=\"java\">//数组初始化不赋值默认为0\ndataType[] arr; //首选\ndataType arr[]; //效果相同但不是首选\ndataType[] arr = new dataType[arraySize]; //使用new操作符创建数组\narr.length;//获取数组的长度</code></pre>\n</li>\n<li><h2 id=\"数组使用\"><a href=\"#数组使用\" class=\"headerlink\" title=\"数组使用\"></a>数组使用</h2><ul>\n<li>数组变量属于引用类型,数组本身是对象,数组对象本身存在于堆中</li>\n</ul>\n<pre><code class=\"java\">int[] arr = new int[5];\n//遍历\nfor (int i=0;i&lt;arr.length;i++)&#123;\n    //执行语句\n&#125;\nfor (int val : arr)&#123;\n    //执行语句\n&#125;\n//入参和返回值\npublic static int[] reverse(int[] arr)&#123;\n   //执行语句\n&#125;</code></pre>\n</li>\n<li><h2 id=\"多维-常用的二维-数组\"><a href=\"#多维-常用的二维-数组\" class=\"headerlink\" title=\"多维(常用的二维)数组\"></a>多维(常用的二维)数组</h2><ul>\n<li><p>二维数组是一个特殊的一位数组,其中每一个元素都是一个一维数组</p>\n<pre><code class=\"java\">int[][] arr = new int[2][5];\nint[][] arr = &#123;&#123;1,2,3,4,5&#125;,&#123;6,7,8,9,0&#125;&#125;\narr[0][3];//4\n//二维数组遍历\nfor(int i=0;i&lt; arr.length;i++)&#123;\n    for(int j=0;j&lt;arr[i].length;j++)&#123;\n         //执行语句\n&#125;\nfor (int[] ins : arr)&#123;\n    for (int val : arr)&#123;\n        //执行语句\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p>三维以上此次类推</p>\n</li>\n</ul>\n</li>\n<li><h2 id=\"Array类\"><a href=\"#Array类\" class=\"headerlink\" title=\"Array类\"></a>Array类</h2><ul>\n<li><p>java的工具类: java.util.Arrays</p>\n<pre><code class=\"java\">import java.util.Arrays;\nint[] arr=&#123;1,4,3,2&#125;;\nArrays.toString(arr);//[1, 4, 3, 2]\nArrays.sort(arr); //[1,2,3,4]\nArrays.fill(arr,0);//当arr部分为空时,那部分会被0填充\nArrays.fill(arr,2,4,1); //第2到4之间的元素会被1填充\n//冒泡排序,八大排序算法之一\npublic static void bubbleSort(int[] arr)&#123;\n    int temp;\n      for (int i=0;i&lt;arr.length-1;i++)&#123;\n        for(int j=0;j&lt;arr.length-i-1;j++)&#123;\n            if(arr[j+1]&gt;arr[j])&#123;\n                temp = arr[j+1];\n                arr[j+1]= arr[j];\n                arr[j] = arr[j+1];\n            &#125;\n        &#125;\n    &#125;  \n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><h2 id=\"稀疏数组\"><a href=\"#稀疏数组\" class=\"headerlink\" title=\"稀疏数组\"></a>稀疏数组</h2><ul>\n<li><p>二维数组存储数据初始化很多没有意义的数据0</p>\n</li>\n<li><p>一种数据结构,把不同元素的行和列记录在一个小规模的数组中,其本身也是一个二维数组</p>\n</li>\n<li><p>稀疏矩阵解读</p>\n<ul>\n<li>第一行表明二维数组矩阵的row和col,以及二维数组所含有效数据个数8</li>\n<li>接下来第二行至第八行分别表示二维矩阵的有效数字所在位置的行(0<del>5),列(0</del>6)和其值</li>\n</ul>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-27_12-44-46.png\" alt=\"稀疏数组\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h1 id=\"java内存\"><a href=\"#java内存\" class=\"headerlink\" title=\"java内存\"></a>java内存</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-26_19-16-05.png\" alt=\"java内存\"></p>\n",
            "tags": [
                "Java笔记",
                "java",
                "笔记",
                "算法"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/01/26/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8C%85%E6%9C%BA%E5%88%B6%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/",
            "url": "https://honshen.xyz/2021/01/26/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8C%85%E6%9C%BA%E5%88%B6%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/",
            "title": "第2章-包机制、流程控制及循环结构",
            "date_published": "2021-01-26T04:28:45.000Z",
            "content_html": "<h1 id=\"Java笔记–第2章包机制、流程控制及循环结构\"><a href=\"#Java笔记–第2章包机制、流程控制及循环结构\" class=\"headerlink\" title=\"Java笔记–第2章包机制、流程控制及循环结构\"></a>Java笔记–第2章包机制、流程控制及循环结构</h1><h1 id=\"包机制\"><a href=\"#包机制\" class=\"headerlink\" title=\"包机制\"></a>包机制</h1><blockquote>\n<p>包的本质是文件夹,用于区别类名的命名空间</p>\n<p>一般使用公司域名倒置做为包名</p>\n<pre><code class=\"java\">//www.baidu.com其包名为com.baidu.www\n//项目文件右上角设置里取消勾选Compact Middle Package\npackage com.baidu.www; //在最上面\nimport java.util.Date; //导入包,语句必须在package下面\nimport com.baidu.*;//导入所有类</code></pre>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-26_13-27-13.png\" alt=\"包机制\"></p>\n</blockquote>\n<h1 id=\"javaDoc\"><a href=\"#javaDoc\" class=\"headerlink\" title=\"javaDoc\"></a>javaDoc</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-26_13-30-07.png\" alt=\"javaDoc\"></p>\n<pre><code class=\"java\">package xyz.honshen;\n/**\n * @author honshen\n * @version 1.1\n * @since 1.8 开发java的版本jdk1.8\n */\npublic class HelloWord &#123;\n    String name;\n    public static void main(String[] args) &#123;\n    &#125;\n    /**\n     * \n     * @param name\n     * @return\n     * @throws Exception\n     */\n    public String test(String name) throws Exception&#123;\n        return  name;\n    &#125;\n&#125;</code></pre>\n<h1 id=\"java的Scanner对象–与用户交互\"><a href=\"#java的Scanner对象–与用户交互\" class=\"headerlink\" title=\"java的Scanner对象–与用户交互\"></a>java的Scanner对象–与用户交互</h1><blockquote>\n<h2 id=\"Scanner基本语法\"><a href=\"#Scanner基本语法\" class=\"headerlink\" title=\"Scanner基本语法:\"></a>Scanner基本语法:</h2><pre><code class=\"java\">Scanner s= new Scanner(System.in);\n//通过Scanner类的next()与nextLine()方法获取输入的字符串,在读取输入数据以前需要使用hasNext()或hasNextLine()判断是否还有输入的数据</code></pre>\n<pre><code class=\"java\">package xyz.honshen;\nimport java.util.Scanner;\npublic class HelloWord &#123;\n    public static void main(String[] args) &#123;\n        Scanner s = new Scanner(System.in);\n        System.out.println(&quot;next接收输入: &quot;);\n        //判断用户是否输入\n        if (s.hasNext()) &#123;\n            String str = s.next();  //next方式接收,只能到空格结束\n            //println会换行,print不会换行\n            System.out.println(&quot;输入内容为: &quot; + str);    //输出输入内容\n        &#125;\n        System.out.println(&quot;nextline接收输入: &quot;);\n        if (s.hasNextLine())&#123;\n            String str = s.nextLine(); //nextLine方式接收,接收一行到\\n结束\n            System.out.println(&quot;输入内容为: &quot;+ str); //输出输入内容\n        &#125;\n        s.close(); //关闭Scanner io流必须关闭否则会占用资源\n    &#125;\n&#125;</code></pre>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-26_14-25-19.png\" alt=\"next和nextline区别\"></p>\n</blockquote>\n<blockquote>\n<h2 id=\"Scanner进阶\"><a href=\"#Scanner进阶\" class=\"headerlink\" title=\"Scanner进阶\"></a>Scanner进阶</h2><pre><code class=\"java\">Scanner s= new Scanner(System.in);\nint a;\nfloat b;\n//接收小数和整数,判断输入是否为整数或小数\nif (s.hasNextInt())&#123;\n     a=s.nextInt();\n     System.out.println(&quot;a: &quot;+a);\n&#125;\nelse if (s.hasNextFloat())&#123;\n      b=s.nextFloat();\n      System.out.println(&quot;b: &quot;+b);\n&#125;\n s.close();\n//同理还有nextDouble等</code></pre>\n</blockquote>\n<h1 id=\"java程序之顺序–选择–循环结构-break-continue\"><a href=\"#java程序之顺序–选择–循环结构-break-continue\" class=\"headerlink\" title=\"java程序之顺序–选择–循环结构(break,continue)\"></a>java程序之顺序–选择–循环结构(break,continue)</h1><blockquote>\n<h2 id=\"顺序结构\"><a href=\"#顺序结构\" class=\"headerlink\" title=\"顺序结构\"></a>顺序结构</h2><ul>\n<li><p>一句一句执行,从上往下</p>\n<pre><code class=\"java\">//从上到下输出1 2 3\npublic static void main(String[] args) &#123;\n        System.out.println(&quot;1&quot;);\n        System.out.println(&quot;2&quot;);\n        System.out.println(&quot;3&quot;);\n    &#125;</code></pre>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<h2 id=\"选择结构\"><a href=\"#选择结构\" class=\"headerlink\" title=\"选择结构\"></a>选择结构</h2><ul>\n<li><p>if选择结构</p>\n<pre><code class=\"java\">String s = &quot;abc&quot;\n//string.equals(&quot;str&quot;)判断字符串是否一致\n//if语句的嵌套\nif(s.equals(&quot;abc&quot;))&#123;\n    //执行语句\n    if(a&lt;b)&#123;\n        //执行语句\n    &#125;\n&#125;\n//多个判断\nif(a&lt;b)&#123;\n    //执行语句1\n&#125;else if(a&lt;c)&#123;\n    //执行语句2\n&#125;else if(a&lt;d)&#123;\n    //执行语句3\n&#125;else&#123;\n    //执行语句4\n&#125;</code></pre>\n</li>\n<li><p>switch选择结构</p>\n<pre><code class=\"java\">//从javase7开始支持比较字符串,本质是比较数字(hash数字)\nswitch(表达式)&#123;\n    //本质是hashcode编码\n    /*\n    在文件路径下输入cmd+空格然后回车可直接进入cmd\n    将编译的class文件用idea直接打开获得反编译文件反编译后结果,如下\n    String name = &quot;abc&quot;;\n    switch(name.hashCode())&#123;\n        case 9987: \n            //语句\n            break;\n    &#125;\n    */\n    case &quot;中国&quot;:\n        //语句\n        break;\n    //不加break,则case穿透会一直执行到break\n    case value: \n        //语句\n        break;\n    default value://可选\n        //语句\n        break;\n&#125;</code></pre>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<h2 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a>循环结构</h2><ul>\n<li><p>while</p>\n<pre><code class=\"java\">while(布尔表达式)&#123;\n    //执行语句\n&#125;\nwhile(true)&#123;\n    //无限循环,常用于服务器监听\n&#125;</code></pre>\n</li>\n<li><p>do-while</p>\n<pre><code class=\"java\">do&#123;\n    //执行语句,至少执行一次\n&#125;while(布尔表达式)</code></pre>\n</li>\n<li><p>for</p>\n<pre><code class=\"java\">for(初始化;布尔表达式;更新)&#123;\n    //执行语句\n&#125;\n//例如:\nfor(int i=0;i&lt;100;i++)&#123;\n    //执行语句\n    //在idea输入100.for可以直接获得100次的for循环结构\n&#125;</code></pre>\n</li>\n<li><p>增强型for循环</p>\n<pre><code class=\"java\">//jdk5引入的特性,主要遍历数组和集合\nfor(声明语句:表达式)&#123;\n    //执行语句\n&#125;\n//例如数组遍历: \nint[] numbers = &#123;10,20,30&#125;; //定义一个数组\nfor (int i=0; i&lt;3; i++)&#123;\n    numbers[i]; //每次循环numbers[i]为: 10,20,30\n&#125;\nfor (int val : numbers)&#123;\n    val;//每次循环val为: 10, 20, 30\n&#125;</code></pre>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<h2 id=\"break和continue-组合成类似goto语句\"><a href=\"#break和continue-组合成类似goto语句\" class=\"headerlink\" title=\"break和continue  组合成类似goto语句\"></a>break和continue  组合成类似goto语句</h2><ul>\n<li>break用于循环和switch,强制退出循环或语句块</li>\n<li>continue只用于循环,跳过本次循环,进入下一次循环</li>\n<li>goto语句:java中保留字含有goto,但并未得到使用,给语句加上label,通过break和continue实现(不建议使用了解即可)</li>\n</ul>\n<pre><code class=\"java\">while(true)&#123;\n    if(布尔表达式)\n        break;//结束循环\n    if(布尔表达式)\n        continue;//进入下一次循环\n    //执行语句\n&#125;\n//利用label求质数\nouter: for (int i=1;i&lt;100;i++)&#123;\n            for(int j=2;j&lt;i/2;j++)&#123;\n                if (i%j==0) &#123;//有其他因数,则不是质数\n                    continue outer;\n                &#125;\n            &#125;\n            System.out.println(i);\n        &#125;</code></pre>\n</blockquote>\n",
            "tags": [
                "Java笔记",
                "java",
                "笔记",
                "算法"
            ]
        },
        {
            "id": "https://honshen.xyz/2021/01/25/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E4%B8%80%E7%AB%A0HelloWord/",
            "url": "https://honshen.xyz/2021/01/25/Java/Java%E7%AC%94%E8%AE%B0--%E7%AC%AC%E4%B8%80%E7%AB%A0HelloWord/",
            "title": "第1章-HelloWord基础",
            "date_published": "2021-01-25T04:20:45.000Z",
            "content_html": "<h1 id=\"Java笔记–第1章HelloWord基础\"><a href=\"#Java笔记–第1章HelloWord基础\" class=\"headerlink\" title=\"Java笔记–第1章HelloWord基础\"></a>Java笔记–第1章HelloWord基础</h1><h1 id=\"第一个java程序\"><a href=\"#第一个java程序\" class=\"headerlink\" title=\"第一个java程序\"></a>第一个java程序</h1><blockquote>\n<p>Tips: </p>\n<ol>\n<li><p>文件名与类名一致(<em>类名大写,这是规范</em>),且在该文件的目录下执行java命令</p>\n</li>\n<li><p>大小写敏感</p>\n</li>\n<li><p>javac 文件名.java – <strong>javac生成的是文件名.class文件</strong></p>\n</li>\n<li><p>java 文件名 – <strong>java执行的是文件名.class文件,执行java命令文件名不用带后缀class</strong></p>\n<pre><code class=\"java\">//demo类需要与文件名一致\npublic class HelloWord&#123;\n    //idea输入psvm可以直接获得public static void main (String[] args) &#123;&#125;\n    public static void main (String[] args) &#123; //参数不能写错\n        //idea输入sout能够直接获得ystem.out.print(&quot;&quot;);\n        System.out.print(&quot;Hello Word!&quot;); //大小写敏感\n    &#125;\n&#125;</code></pre>\n</li>\n</ol>\n</blockquote>\n<h1 id=\"java程序运行机制\"><a href=\"#java程序运行机制\" class=\"headerlink\" title=\"java程序运行机制\"></a>java程序运行机制</h1><ul>\n<li>编译型(一次性全部编译,执行速度快)</li>\n<li>解释型(即时编译,边执行边编译)</li>\n</ul>\n<h1 id=\"java入门语法\"><a href=\"#java入门语法\" class=\"headerlink\" title=\"java入门语法\"></a>java入门语法</h1><blockquote>\n<p>注释(3种): </p>\n<pre><code class=\"java\">//单行注释\n\n/*\n多行\n注释\n*/\n\n/**\n*javaDoc文档注释\n*@author 解释\n*这是有功能的注释\n*/</code></pre>\n</blockquote>\n<h1 id=\"java关键字及标识符\"><a href=\"#java关键字及标识符\" class=\"headerlink\" title=\"java关键字及标识符\"></a>java关键字及标识符</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-25_19-46-59.png\" alt=\"java标识符\"></p>\n<blockquote>\n<p>标识符以  字母  $  _   开头,首字母之后可以是 字母 $  _  数字  的任何组合</p>\n<p>不能使用关键字,且大小写敏感也可以中文命名\\</p>\n<p>java是强类型语言,所有变量必须先定义后使用</p>\n</blockquote>\n<h1 id=\"java数据类型\"><a href=\"#java数据类型\" class=\"headerlink\" title=\"java数据类型\"></a>java数据类型</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-25_20-08-07.png\" alt=\"java数据类型\"></p>\n<blockquote>\n<p>常用数据类型:</p>\n<pre><code class=\"java\">//整数\nint num1 = 10;\n\nbyte num2 = 10;\n\nshort num3 = 10;\n\nlong num4 = 10L; //long类型需要数字后加L以区分\n\n//小数\n\nfloat num5 = 10.0F;//浮点类型需要数字后加F区分double\n\ndouble num6= 10.0;\n\n//字符\nchar ch = &#39;a&#39;;\n\n//字符串\nString str = &quot;abc&quot;; //String不是关键字而是一个类\n\n//布尔值\nboolean flag = false;</code></pre>\n<p>整数扩展</p>\n<pre><code class=\"java\">int num1 = 10; //十进制\nint num2 = 010;//0开头表示八进制,结果为8(十进制)\nint num3 = 0x10;//0x开头表示十六进制,结果为16(十进制)\nint num4 = 0b10;//0b开头表示二进制,结果为2(十进制)\nint num5 = 100_0000_0000; //数字之间可以使用下划线分开\n//浮点数 有限 离散 舍入误差 大约 接近但不等于\n//不要使用浮点数比较使用类BigDecimal\n//所有的字符本质是数字可以强制转换\nchar c1 = &#39;a&#39;;\nchar c2 = &#39;中&#39;;\nint num6 = (int)c1; //97\nint num7 = (int)c2; //20013\n//unicode编码U0000-UFFFF\nchar ch1 = &#39;\\u0061&#39;; //十六进制转义字符表示字符&#39;a&#39;\n//转义字符: 水平制表符: \\t 垂直制表符: \\r 换行: \\n 退格: \\b \\: \\\\ &quot;: \\&quot;</code></pre>\n<p>类型转换</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-25_20-55-23.png\" alt=\"类型转换\"></p>\n<pre><code class=\"java\">int i = 128;\nbyte b = (byte)i; //内存溢出--强制转换(高--&gt;低)\ndouble c = i; //自动转换(低--&gt;高)\n//不能对boolean转换\n//不能把对象类型转换为不相干类型\n//把高容量向低容量需要强制转换\n//进行转换可能会出现精度损失和内存溢出\n//注意计算溢出\nint money = 10_0000_0000;\nint years = 20;\nint total1= money*years;//溢出,结果为负数\nlong total2= money*years;//计算结果已经溢出在将溢出结果进行转换,结果为负数\n//建议: long total3=money*((long)years);先将其中一个强制另一个自动转换</code></pre>\n</blockquote>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><ol>\n<li><p>java是强类型语言,每个变量都必须声明其类型</p>\n</li>\n<li><p>每个变量都有类型,类型可以是基本类型也可以是引用类型</p>\n</li>\n<li><p>变量名必须是合法的标识符</p>\n</li>\n<li><p>变量声明是一条完整的语句,每一个声明以分号结束</p>\n<pre><code class=\"java\">//数据类型 变量名 = 值;\ntype varName [=value] [&#123;,varName=[value]&#125;];\n//可以使用逗号隔开以申明多个变量\nint a=1,b=2,c=3;\n//也可以\nint a=1;\nint b=2;</code></pre>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><blockquote>\n<pre><code class=\"java\">public class Varlue &#123;\n    static int num = 100; //类变量\n    String ch = &#39;abc&#39;; //实例变量,方法外面,类的里面,从属于对象,如果不初始化会赋予一个默认值\n    //默认情况: 布尔值:false 字符串: U0000 整形: 0 浮点:0.0 除了基本类型其余为null\n    public void method()&#123;\n        int i = 0; //局部变量,只在方法内method&#123;&#125;能够使用\n        Varlue demo = new Varlue;\n        demo.ch;//abc\n    &#125;\n&#125;</code></pre>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><blockquote>\n<p>初始化后不能改变的值</p>\n<pre><code class=\"java\">//常量名一般使用大写字符\nfinal double PI = 3.1415;\n//修饰符不区分前后\npublic class Var &#123;\n    //不区分前后\n    static final double PI = 3.14;\n    final static double PI = 3.14;\n&#125;</code></pre>\n</blockquote>\n<h1 id=\"变量命名规范\"><a href=\"#变量命名规范\" class=\"headerlink\" title=\"变量命名规范\"></a>变量命名规范</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-25_22-52-09.png\" alt=\"变量命名\"></p>\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-26_12-27-39.png\" alt=\"运算符\"></p>\n<pre><code class=\"java\">//如果操作数其中一个为long类型其结果为long类型\n//如果操作数其中一个为double其类型为double\nlong a=10;\nint b=10;\ndouble c=10.0;\na+b;//结果为long类型\na+c;//结果为double类型\n//如果操作数为short,byte其结果也为long\nshort c=10;\nbyte d = 10;\nc+d;//结果为int类型\n//自增,自减运算符,一元运算符\na++;\nb--;\n++c;\n--d;\n//幂运算使用工具类\ndouble pow = Math.pow(2,3); //2^3=8\n//短路运算: &amp;&amp;左边为假时不执行右边的算法\nboolean a=false;\nboolean b=true;\na&amp;&amp;b;//不会执行b语句\n//位运算: &amp; | ^ ~\n/*\nA = 0011 1100\nB = 0000 1101\nA&amp;B = 0000 1100\nA|B = 0011 1101 //一个为1即为1\nA^B = 0011 0001 //相同为0不同为1\n~B = 1111 0010\n2*8怎么运算最快?\n2&lt;&lt;3\n左移: &lt;&lt; 相当于 *2\n右移: &gt;&gt; 相当于 /2\n位运算效率极高!\n*/\n//扩展运算符\na+=5; //a=a+5;\nb-=5;\nc*=5;\nd/=5;\n//字符串连接符 +\nint a=10;\nint b=20;\n&quot;&quot;+a+b;//1020 将字符串拼接\na+b+&quot;&quot;;//30 先运算a+b为int再进行拼接\n//三元运算符\nx?y:z; //如果x语句为真执行y否则执行z</code></pre>\n",
            "tags": [
                "Java笔记",
                "java",
                "笔记",
                "算法"
            ]
        },
        {
            "id": "https://honshen.xyz/2020/12/24/MarkDown/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",
            "url": "https://honshen.xyz/2020/12/24/MarkDown/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",
            "title": "Markdown使用指南",
            "date_published": "2020-12-24T04:10:45.000Z",
            "content_html": "<h1 id=\"MarkdownNote\"><a href=\"#MarkdownNote\" class=\"headerlink\" title=\"MarkdownNote\"></a>MarkdownNote</h1><p>common grammar–MarkdownNote</p>\n<p>推荐markdown软件<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudHlwb3JhLmlvLw==\">Typora</span></p>\n<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h1><blockquote>\n<p><strong>使用技巧:  “#” + 空格 + 文本</strong></p>\n<pre><code class=\"markdown\">###### 六级标题\n### 三级标题\n## 二级标题\n# 一级标题</code></pre>\n<p><strong>效果如下:</strong></p>\n<h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1></blockquote>\n<h1 id=\"title\"><a href=\"#title\" class=\"headerlink\" title=\"title\"></a>title</h1><blockquote>\n<p><strong>使用技巧: title下方  + ‘’  = “ 或 “ - “</strong></p>\n<pre><code class=\"markdown\">Second Title(-的数量随意)\n------\n\nFirst Title(=的数量随意)\n===</code></pre>\n<p><strong>效果如下:</strong></p>\n<h2 id=\"Second-Title-的数量随意\"><a href=\"#Second-Title-的数量随意\" class=\"headerlink\" title=\"Second Title(-的数量随意)\"></a>Second Title(-的数量随意)</h2><h1 id=\"First-Title-的数量随意\"><a href=\"#First-Title-的数量随意\" class=\"headerlink\" title=\"First Title(=的数量随意)\"></a>First Title(=的数量随意)</h1></blockquote>\n<h1 id=\"字体样式\"><a href=\"#字体样式\" class=\"headerlink\" title=\"字体样式\"></a>字体样式</h1><blockquote>\n<ol>\n<li><p><strong>加粗使用技巧: “**“ +文本+ “**“</strong> </p>\n<pre><code class=\"markdown\">**这是加粗文本**</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><strong>这是加粗文本</strong></p>\n</li>\n<li><p><strong>斜体使用技巧: “*“+文本+”*“</strong></p>\n<pre><code class=\"markdown\">*这是斜体*</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><em>这是斜体</em></p>\n</li>\n<li><p><strong>粗斜体使用技巧:  “***“+ 文本+”***“</strong></p>\n<pre><code class=\"markdown\">***这是粗斜体***</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><strong><em>这是粗斜体</em></strong></p>\n</li>\n</ol>\n</blockquote>\n<h1 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h1><blockquote>\n<p><strong>分割线使用技巧: 文本下方 + 3个”_”</strong></p>\n<pre><code class=\"markdown\">下划线在文本下方(_3个)\n___</code></pre>\n<p><strong>效果如下:</strong></p>\n<p>下划线在文本下方(_3个)</p>\n<hr>\n</blockquote>\n<h1 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h1><blockquote>\n<p><strong>删除线使用技巧: “~~“ + 文本 + ‘’~~“</strong></p>\n<pre><code class=\"bash\">~~我不会markdown~~</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><del>我不会markdown</del></p>\n</blockquote>\n<h1 id=\"代码插入\"><a href=\"#代码插入\" class=\"headerlink\" title=\"代码插入\"></a>代码插入</h1><blockquote>\n<p><strong>小块代码使用技巧: “&#96;” + 代码语句 +  “ ` “</strong></p>\n<pre><code class=\"markdown\">`npm install hexo-cli --save`</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><code>npm install hexo-cli --save</code></p>\n<p><strong>区域代码块使用技巧: “ ```语言类型 “+ {代码块} +”```”</strong></p>\n<pre><code class=\"markdown\">​```java\npublic class demo &#123;\n    //代码块\n&#125;\n​```</code></pre>\n<p><strong>效果如下:</strong></p>\n<pre><code class=\"java\">public class demo &#123;\n    //代码块\n&#125;</code></pre>\n<p><strong>tips: 常用语言类型有c、c++、java、javascript、html、css、nodejs、bash、cmd、markdown等</strong></p>\n</blockquote>\n<h1 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h1><blockquote>\n<p><strong>使用技巧: “&gt;”+空格</strong></p>\n<pre><code class=\"markdown\">&gt; 第一列\n&gt; &gt; 第二列\n&gt; &gt; &gt; 第三列</code></pre>\n<p><strong>效果如下:</strong></p>\n<blockquote>\n<p>第一列</p>\n<blockquote>\n<p>第二列</p>\n<blockquote>\n<p>第三列</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<h1 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h1><blockquote>\n<p><strong>使用技巧: “[“+文本+”]”+”(“+地址+”)”</strong></p>\n<pre><code class=\"markdown\">[百度一下,点击前往百度](https://baidu.com)</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlkdS5jb20v\">百度一下,点击前往百度</span></p>\n<p><strong>tips: 中括号中的内容是显示的链接文字,地址可以是网路地址也可以是本机文件的绝对地址</strong></p>\n</blockquote>\n<h1 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h1><blockquote>\n<p><strong>使用技巧: “!”+”[“+文本+”]”+”(“+地址+”)”</strong></p>\n<pre><code class=\"markdown\">![profile](https://avatars0.githubusercontent.com/u/61302414?s=120&amp;v=4)</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><img data-src=\"https://avatars0.githubusercontent.com/u/61302414?s=120&v=4\" alt=\"profile\"></p>\n<p><strong>tips: 中括号中的文本是对图像的一段描述,如果图像加载失败将会显示中括号中的文本,地址可以是网络地址也可以是本机图像文件的绝对地址</strong> </p>\n</blockquote>\n<h1 id=\"待解释\"><a href=\"#待解释\" class=\"headerlink\" title=\"待解释\"></a>待解释</h1><blockquote>\n<p><strong>使用技巧: “[“+”^”+文本+”]”</strong></p>\n<pre><code class=\"markdown\">GitHub[^ex]\n[^ex]: Build software better, together</code></pre>\n<p><strong>效果如下:</strong></p>\n<p>GitHub[^ex]</p>\n<p>[^ex]: Build software better, together</p>\n<p><strong>tips: 一般待解释需要放到文档或网页的页脚进行注释</strong></p>\n</blockquote>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><blockquote>\n<ol>\n<li><p><strong>无序列表使用技巧: “+” 或 “-“ + 文本</strong></p>\n<pre><code class=\"markdown\">+ 无序列表1\n+ 无序列表2\n- 无序列表3\n- 无序列表4</code></pre>\n<p><strong>效果如下:</strong></p>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n</ul>\n<ul>\n<li>无序列表3</li>\n<li>无序列表4</li>\n</ul>\n</li>\n<li><p><strong>有序列表使用技巧: 数字 + “.” + 文本</strong></p>\n<pre><code class=\"markdown\">1. 有序列表1\n2. 有序列表2</code></pre>\n<p>**效果如下: **</p>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><blockquote>\n<pre><code class=\"markdown\">| TITLE | COL  | COL  |\n| ----- | ---- | ---- |\n| ROW1  | ROW1 | ROW1 |\n| ROW2  | ROW2 | ROW2 |</code></pre>\n<p><strong>效果如下:</strong></p>\n<table>\n<thead>\n<tr>\n<th>TITLE</th>\n<th>COL</th>\n<th>COL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ROW1</td>\n<td>ROW1</td>\n<td>ROW1</td>\n</tr>\n<tr>\n<td>ROW2</td>\n<td>ROW2</td>\n<td>ROW2</td>\n</tr>\n</tbody></table>\n</blockquote>\n<h1 id=\"网页\"><a href=\"#网页\" class=\"headerlink\" title=\"网页\"></a>网页</h1><blockquote>\n<p><strong>tips: Markdown支持使用Html,只要你会使用Html,就可以做到任何事!</strong></p>\n<pre><code class=\"html\">&lt;img src=&quot;https://avatars0.githubusercontent.com/u/61302414?s=120&amp;v=4&quot; style=&quot;zoom=50%&quot;/&gt;\n&lt;a href=&quot;https://baidu.com/&quot;&gt;百度一下&lt;/a&gt;</code></pre>\n<p><strong>效果如下:</strong></p>\n<img data-src=\"https://avatars0.githubusercontent.com/u/61302414?s=120&v=4\" style=\"zoom=50%\"/>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlkdS5jb20v\">百度一下</span>\n</blockquote>\n<h1 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h1><blockquote>\n<p><strong>当你想使用一些特殊字符时如: <code>&gt; &lt; #</code>等,可能会被markdown语法解析下面有两种方法防止语法被解析:</strong></p>\n<ol>\n<li><p>使用``反引号`来防止被解析,反引号位于esc键下方,被两个反引号包裹的内容不会被解析</p>\n<pre><code class=\"markdown\">`&gt; &lt; # ![图片](src) [链接](href)`</code></pre>\n<p><strong>效果如下:</strong></p>\n<p><code>&gt; &lt; # ![图片](src) [链接](href)</code></p>\n</li>\n<li><p>使用转义字符: <code>\\</code>来防止语法被解析,如下: </p>\n<pre><code class=\"markdown\">\\&gt; \n\\&lt;\n\\\\\n\\#</code></pre>\n<p><strong>效果如下:</strong></p>\n<p>&gt;<br>&lt;<br>\\<br>#</p>\n<p><strong>tips: 如果想要使用反引号可以使用<code>&amp;#96;</code>来表示  `</strong></p>\n</li>\n</ol>\n</blockquote>\n",
            "tags": [
                "Markdown使用指南",
                "笔记",
                "Markdown"
            ]
        },
        {
            "id": "https://honshen.xyz/2020/12/13/Hexo/%E7%AC%AC1%E7%AB%A0-%E9%9B%B6%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BHEXO%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96/",
            "url": "https://honshen.xyz/2020/12/13/Hexo/%E7%AC%AC1%E7%AB%A0-%E9%9B%B6%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BHEXO%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96/",
            "title": "第1章-零基础使用HEXO搭建个人博客之HEXO及其初始化",
            "date_published": "2020-12-13T04:12:45.000Z",
            "content_html": "<h1 id=\"零基础HEXO搭建个人博客之HEXO安装及其初始化\"><a href=\"#零基础HEXO搭建个人博客之HEXO安装及其初始化\" class=\"headerlink\" title=\"零基础HEXO搭建个人博客之HEXO安装及其初始化\"></a>零基础HEXO搭建个人博客之HEXO安装及其初始化</h1><p><strong>引言: 很多小伙伴都希望搭建一个属于自己的博客平台,今天这篇文章教会大家如何0基础也能搭建个人博客,我们使用Hexo来帮助我们搭建个人博客~</strong></p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><blockquote>\n<ol>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9iZWJiYTBkODAzOGU=\">安装git</span>–<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS8=\">git官网</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xM2Y0NWUyNGIxZGU=\">安装nodejs</span>–<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==\">nodejs官网</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8wYzBkOGQxMGExY2I=\">注册github</span>–创建一个和Username一样名称的仓库</p>\n<p><img data-src=\"https://s3.ax1x.com/2020/12/08/rSNdZ8.md.png\" alt=\"创建仓库\"></p>\n<blockquote>\n<p>Tips: 创建仓库名如果与Username不一致,请在下文初始化博客和配置博客文件时使用和仓库名一样的名字!!! <strong>访问链接https://仓库名.github.io访问</strong> </p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><blockquote>\n<ol>\n<li><p>在任意文件夹里,点击鼠标右键,选择Git bash here,打开git bash输入配置信息</p>\n<blockquote>\n<pre><code class=\"bash\">git config --global user.name &quot;用户名&quot;\ngit config --global user.email &quot;邮箱地址&quot;</code></pre>\n<pre><code class=\"bash\"># 例如:\ngit config --global user.name &quot;hongsheng-xu&quot;\ngit config --global user.email &quot;1394948572@qq.com&quot;</code></pre>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li><p>在git bash 里输入</p>\n<blockquote>\n<pre><code class=\"bash\">ssh-keygen -t rsa -C  &quot;邮箱地址&quot;</code></pre>\n<pre><code class=\"bash\">#例如: \nssh-keygen -t rsa -C  &quot;1394948572@qq.com&quot;</code></pre>\n</blockquote>\n</li>\n</ol>\n<p>控制台输出如下: </p>\n<pre><code class=\"bash\">Enter file in which to save the key (/c/Users/13949/.ssh/id_rsa):\nCreated directory &#39;/c/Users/13949/.ssh&#39;.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /c/Users/13949/.ssh/id_rsa\nYour public key has been saved in /c/Users/13949/.ssh/id_rsa.pub\nThe key fingerprint is:\n#后文输出省略......</code></pre>\n<pre><code class=\"cmd\"># 打开目录--控制台第二行输出Created directory &#39;/c/Users/13949/.ssh&#39;.其中ssh的存放路径为:\nC:\\Users\\13949\\.ssh\n# 打开github&gt;点击个人头像&gt;点击设置(Settings)&gt;点击SSH and GPG keys&gt;New SSH key&gt;在路径:C:\\Users\\13949\\.ssh记事本打开id_rsa.pub文件,复制全部到New SSH key中key内容里</code></pre>\n<p><a href=\"https://imgchr.com/i/rSdmMn\"><img data-src=\"https://s3.ax1x.com/2020/12/08/rSdmMn.md.png\" alt=\"rSdmMn.md.png\"></a></p>\n</blockquote>\n<h1 id=\"Hexo安装\"><a href=\"#Hexo安装\" class=\"headerlink\" title=\"Hexo安装\"></a>Hexo安装</h1><blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv\">hexo文档</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">hexo安装</span></p>\n</blockquote>\n<blockquote>\n<pre><code class=\"cmd\"># 安装hexo, win+R,输入cmd 打开控制台输入: \ne: \nmd blog\ncd blog\nnpm install hexo-cli -g\n#列如: \nC:\\Users\\13949&gt;e:\nE:\\&gt;md blog\nE:\\&gt;cd blog\nE:\\blog&gt;npm install hexo-cli -g</code></pre>\n<p><strong>Tips: 通过上述代码在E盘创建了一个名为blog的文件夹,接下来我们需要做的就是初始化个人博客</strong></p>\n</blockquote>\n<h1 id=\"Hexo初始化\"><a href=\"#Hexo初始化\" class=\"headerlink\" title=\"Hexo初始化\"></a>Hexo初始化</h1><blockquote>\n<pre><code class=\"cmd\">#在blog文件夹下初始化博客 hexo init 博客名\nhexo init hongsheng-xu\n#进入博客所在文件夹\ncd hongsheng-xu\n#安装依赖\nnpm i\n#安装插件\nnpm i hexo-deployer-git --save\n#运行博客\nhexo sever\n#上一步也可以这样写--运行博客并指定端口名\nhexo s -p 8080</code></pre>\n<pre><code class=\"cmd\">#列如:\nE:\\blog&gt;hexo init hongsheng-xu\nE:\\blog&gt;cd hongsheng-xu\nE:\\blog&gt;hongsheng-xu&gt;npm i\nE:\\blog&gt;hongsheng-xu&gt;npm i hexo-deployer-git --save\nE:\\blog&gt;hongsheng-xu&gt;hexo sever</code></pre>\n<p><strong>输入hexo sever后你会看到控制台输出如下:</strong></p>\n<pre><code class=\"cmd\">#INFO  Validating config\n#INFO  Start processing\n#INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre>\n<blockquote>\n<p>完成这一步,nodejs会建立一个本地服务器通常会向Windows请求相关权限</p>\n<p>你可以复制地址 <span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAw5Yiw5rWP6KeI5Zmo55qE5Zyw5Z2A5qCPLOWbnui9puWwseiDveeci+WIsOS4quS6uuWNmuWuouWVpg==\">http://localhost:4000到浏览器的地址栏,回车就能看到个人博客啦</span>!</p>\n<p>同时按住ctrl+c可以停止服务器的运行</p>\n</blockquote>\n<p><strong>搭建好的个人博客大概长这样</strong>: </p>\n<p><a href=\"https://imgchr.com/i/rSBmMd\"><img data-src=\"https://s3.ax1x.com/2020/12/08/rSBmMd.md.png\" alt=\"个人博客\"></a></p>\n</blockquote>\n<h1 id=\"Hexo发布至github\"><a href=\"#Hexo发布至github\" class=\"headerlink\" title=\"Hexo发布至github\"></a>Hexo发布至github</h1><blockquote>\n<ol>\n<li><p>修改博客子目录下_config.yml</p>\n<p><a href=\"https://imgchr.com/i/ri3Y7T\"><img data-src=\"https://s3.ax1x.com/2020/12/10/ri3Y7T.png\" alt=\"修改_config.yml.png\"></a></p>\n<p>修改为https://仓库名.github.io    <strong>这样就可以通过仓库名.github.io去访问个人博客</strong></p>\n<p><a href=\"https://imgchr.com/i/ri3Dj1\"><img data-src=\"https://s3.ax1x.com/2020/12/10/ri3Dj1.png\" alt=\"ri3Dj1.png\"></a></p>\n<p>找到deploy加入几行代码</p>\n<p><a href=\"https://imgchr.com/i/ri8V29\"><img data-src=\"https://s3.ax1x.com/2020/12/10/ri8V29.png\" alt=\"ri8V29.png\"></a></p>\n</li>\n</ol>\n<pre><code class=\"yml\"># Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  branch: master\n  repo: https://github.com/hongsheng-xu/hongsheng-xu.github.io.git</code></pre>\n<p><em>Tips:  这里type指定为git,branch指定为master,如果你有新建分支可以提交到其他分支上,repo里写上自己仓库的地址&gt;打开github&gt;进入自己的博客仓库(博客名.gthub.io这个仓库)&gt;点击下载code&gt;复制地址</em></p>\n<p><a href=\"https://imgchr.com/i/ri8XdK\"><img data-src=\"https://s3.ax1x.com/2020/12/10/ri8XdK.png\" alt=\"ri8XdK.png\"></a></p>\n<ol start=\"2\">\n<li><p>在博客所在的文件夹下点击右键打开git bash安装hexo-deployer-git</p>\n<p><img data-src=\"https://images-1300732204.cos.ap-chengdu.myqcloud.com/MarkDown/Snipaste_2021-01-30_11-35-31.png\" alt=\"博客文件夹\"></p>\n</li>\n</ol>\n<pre><code class=\"bash\"># 在bash里输入以下代码,下载hexo-deployer-git依赖\nnpm install hexo-deployer-git --save</code></pre>\n<ol start=\"3\">\n<li>接着在bash里,编译代码hexo g</li>\n</ol>\n<pre><code class=\"bash\">hexo g</code></pre>\n<ol start=\"4\">\n<li>上传代码(提交到分支) hexo d</li>\n</ol>\n<pre><code class=\"bash\">hexo d</code></pre>\n<p><strong>以后就可以通过https://仓库名.github.io/去访问个人博客了,例如你可以戳此访问搭建好的博客: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ob25nc2hlbmcteHUuZ2l0aHViLmlvLw==\">https://hongsheng-xu.github.io</span></strong></p>\n</blockquote>\n",
            "tags": [
                "HEXO搭建个人博客",
                "Hexo",
                "博客"
            ]
        }
    ]
}